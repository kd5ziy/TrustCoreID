{"version":3,"sources":["webpack:///jose.min.js","webpack:///webpack/bootstrap 64de05bc59c3f0f16cce","webpack:///./~/@trust/json-document/lib/index.js","webpack:///./~/base64url/index.js","webpack:///./~/buffer/index.js","webpack:///./lib/schemas/JWKSchema.js","webpack:///./lib/errors/DataError.js","webpack:///./lib/jose/JWA.js","webpack:///./lib/jose/JWT.js","webpack:///./lib/text-encoder/index.js","webpack:///./~/@trust/json-document/lib/JSONPointer.js","webpack:///external \"crypto\"","webpack:///./lib/errors/NotSupportedError.js","webpack:///./lib/jose/JWD.js","webpack:///./lib/jose/JWK.js","webpack:///./lib/schemas/Base64URLSchema.js","webpack:///./lib/schemas/JOSEHeaderSchema.js","webpack:///./lib/schemas/JWKSetSchema.js","webpack:///./lib/schemas/JWTClaimsSetSchema.js","webpack:///./lib/schemas/JWTSchema.js","webpack:///./~/@trust/json-document/lib/Formats.js","webpack:///./~/@trust/json-document/lib/Initializer.js","webpack:///./~/@trust/json-document/lib/JSONPatch.js","webpack:///./~/@trust/json-document/lib/Validator.js","webpack:///(webpack)/buildin/global.js","webpack:///./lib/index.js","webpack:///./lib/algorithms/ECDSA.js","webpack:///./lib/algorithms/HMAC.js","webpack:///./lib/algorithms/RSASSA-PKCS1-v1_5.js","webpack:///./lib/algorithms/SupportedAlgorithms.js","webpack:///./lib/algorithms/index.js","webpack:///./lib/errors/index.js","webpack:///./lib/formats/index.js","webpack:///./lib/jose/JWKSet.js","webpack:///./~/@trust/json-document/lib/JSONDocument.js","webpack:///./~/@trust/json-document/lib/JSONMapping.js","webpack:///./~/@trust/json-document/lib/JSONSchema.js","webpack:///./~/base64-js/index.js","webpack:///./~/base64url/dist/base64url.js","webpack:///./~/base64url/dist/pad-string.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///external \"TextEncoder\""],"names":["JOSE","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Formats","Initializer","JSONDocument","JSONMapping","JSONPatch","JSONPointer","JSONSchema","Validator","default","global","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","length","RangeError","Uint8Array","__proto__","arg","encodingOrOffset","this","Error","allocUnsafe","from","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","undefined","checked","string","isEncoding","byteLength","actual","write","slice","fromArrayLike","array","byteOffset","obj","isBuffer","len","copy","buffer","isnan","type","isArray","data","toString","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","b","bidirectionalIndexOf","val","dir","isNaN","arrayIndexOf","indexOf","lastIndexOf","arr","read","buf","indexSize","readUInt16BE","arrLength","valLength","String","foundIndex","found","j","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","push","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","replace","INVALID_BASE64_RE","trim","units","Infinity","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","foo","subarray","e","poolSize","_augment","Symbol","species","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","arguments","equals","inspect","match","join","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","Array","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","floor","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","code","_require","_require2","JWKSchema","BASE64_REGEXP","properties","kty","enum","use","key_ops","items","alg","kid","x5u","x5c","x5t","_classCallCheck","instance","Constructor","_possibleConstructorReturn","self","ReferenceError","_typeof","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","iterator","DataError","_Error","message","getPrototypeOf","_createClass","defineProperties","props","descriptor","key","protoProps","staticProps","supportedAlgorithms","NotSupportedError","JWA","normalizedAlgorithm","normalize","Promise","reject","sign","signature","verify","importKey","_typeof2","clean","input","JSON","parse","stringify","base64url","JWTSchema","JWT","_JSONDocument","options","filter","_this","serialization","_len","_key","params","assign","isJWE","_this2","_len2","_key2","payload","protectedHeader","protected","unprotectedHeader","header","signatures","cryptoKey","_params$validate","validate","result","validation","valid","promises","map","encodedHeader","encodedPayload","then","all","serialize","_this3","_len3","_key3","cryptoKeys","index","resolve","verified","reduce","prev","serializedSignatures","toCompact","toFlattened","toGeneral","toJWD","toDocumentGeneral","toDocumentFlattened","token","startsWith","err","fromCompact","fromGeneral","fromFlattened","ExtendedJWT","segments","split","decode","_data","decodedHeader","serialized","unshift","_len4","_key4","_len5","_key5","encode","_len6","_key6","TextEncoder","THROW","expr","mode","tokens","charAt","parseURIFragmentIdentifier","parseJSONString","unescape","escape","decodeURIComponent","encodeURIComponent","source","current","splice","crypto","JWD","_JWT","toJWT","fromDocumentGeneral","fromDocumentFlattened","ExtendedJWD","_data2","JWK","jwk","Base64URLSchema","format","JOSEHeaderSchema","typ","cty","jku","crit","minItems","enc","zip","JWKSetSchema","keys","JWTClaimsSetSchema","iss","aud","exp","nbf","iat","jti","iv","aad","ciphertext","tag","recipients","encrypted_key","DATETIME_REGEXP","URI_REGEXP","EMAIL_REGEXP","IPV4_REGEXP","IPV6_REGEXP","HOSTNAME_REGEXP","pattern","RegExp","test","formats","register","initialize","schema","root","depth","level","declarations","body","member","item","declaration","block","additionalProperties","additionalItems","forEach","subschema","initializer","compile","_index","Function","console","log","stack","OPERATIONS","ops","operation","op","path","add","remove","pointer","indexCount","address","require","validator","required","number","anyOf","allOf","not","oneOf","keywords","validations","keyword","enumerated","conditions","isRequired","segment","pop","patternValidations","additionalValidations","patternProperties","_schema","otherPropertiesCalled","otherProperties","minProperties","maxProperties","dependencies","dependency","_schema2","counter","maxItems","uniqueItems","minLength","maxLength","matcher","_schema3","minimum","exclusiveMinimum","_schema4","maximum","exclusiveMaximum","multipleOf","decimals","toFixed","condition","g","eval","window","JWKSet","ECDSA","algorithm","subtle","toBuffer","usages","HMAC","bitlength","RSASSA_PKCS1_v1_5","operations","SupportedAlgorithms","argument","registeredAlgorithms","SyntaxError","define","hash","namedCurve","jwks","imported","importing","alternate","mapping","project","RECOVER","Map","right","left","_defineProperty","writeable","isObject","extender","placeHoldersCount","b64","tmp","placeHolders","Arr","L","revLookup","tripletToBase64","num","lookup","encodeChunk","uint8","output","extraBytes","parts","len2","fromBase64","toBase64","pad_string_1","padString","stringLength","diff","position","padLength","paddedStringLength","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","abs","LN2"],"mappings":"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","file":"jose.min.js","sourcesContent":["var JOSE =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 41);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  Formats: __webpack_require__(18),\n  Initializer: __webpack_require__(19),\n  JSONDocument: __webpack_require__(32),\n  JSONMapping: __webpack_require__(33),\n  JSONPatch: __webpack_require__(20),\n  JSONPointer: __webpack_require__(8),\n  JSONSchema: __webpack_require__(34),\n  Validator: __webpack_require__(21)\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(36).default;\nmodule.exports.default = module.exports;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(35);\nvar ieee754 = __webpack_require__(38);\nvar isArray = __webpack_require__(39);\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength();\n\nfunction typedArraySupport() {\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {\n        return 42;\n      } };\n    return arr.foo() === 42 && // typed array instances can be augmented\n    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that;\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error('If encoding is specified then the first argument must be a string');\n    }\n    return allocUnsafe(this, arg);\n  }\n  return from(this, arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;\n};\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);\n  }\n\n  return fromObject(that, value);\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    });\n  }\n}\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');\n  }\n}\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size);\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n  }\n  return createBuffer(that, size);\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);\n};\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that;\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);\n};\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that;\n}\n\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n  }\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\n\nBuffer.compare = function compare(a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');\n  }\n\n  if (a === b) return 0;\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0;\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n      case 'hex':\n        return len >>> 1;\n      case 'base64':\n        return base64ToBytes(string).length;\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>';\n};\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0;\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1;\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset; // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0;\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return '';\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str;\n}\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue;\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n  return i;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\nvar _require2 = __webpack_require__(30),\n    BASE64_REGEXP = _require2.BASE64_REGEXP;\n\n/**\n * JWK Schema\n */\n\nvar JWKSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    kty: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['RSA', 'EC', 'oct'] // other values MAY be used\n    },\n\n    use: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['sig', 'enc'] // other values MAY be used\n    },\n\n    key_ops: {\n      type: 'array',\n      //format: 'case-sensitive',\n      items: {\n        enum: ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'] // other values MAY be used\n      }\n    },\n\n    alg: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512', 'none'] // other values MAY be used\n    },\n\n    kid: {\n      type: 'string'\n    },\n\n    x5u: {\n      type: 'string'\n      //format: 'url'\n    },\n\n    x5c: {\n      type: 'array'\n      //format: BASE64_REGEXP\n    },\n\n    x5t: {\n      type: 'string'\n      //format: BASE64_REGEXP\n\n\n      //'x5t#S256': {\n      //  type: 'string',\n      //  //format: BASE64_REGEXP\n      //}\n    } }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSchema;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * DataError\n */\nvar DataError = function (_Error) {\n  _inherits(DataError, _Error);\n\n  function DataError(message) {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message));\n  }\n\n  return DataError;\n}(Error);\n\n/**\n * Export\n */\n\nmodule.exports = DataError;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\nvar base64url = __webpack_require__(1);\nvar supportedAlgorithms = __webpack_require__(28);\n\nvar _require = __webpack_require__(29),\n    NotSupportedError = _require.NotSupportedError;\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\n\nvar JWA = function () {\n  function JWA() {\n    _classCallCheck(this, JWA);\n  }\n\n  _createClass(JWA, null, [{\n    key: 'sign',\n\n    /**\n     * Sign\n     *\n     * @description\n     * Create a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} key\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n    value: function sign(alg, key, data) {\n      // normalize the algorithm\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg);\n\n      // validate algorithm is supported\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // validate type of key\n      // TODO\n      //  - is the key suitable for the algorithm?\n      //  - does that get validated in webcrypto?\n      //if (key instanceof CryptoKey) {\n      //  return Promise.reject(new InvalidKeyError())\n      //}\n\n      // sign the data\n      return normalizedAlgorithm.sign(key, data);\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} privateKey\n     * @param {string|Buffer} signature\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(alg, key, signature, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // TODO\n      // validate publicKey\n\n      // verify the signature\n      return normalizedAlgorithm.verify(key, signature, data);\n    }\n\n    /**\n     * Encrypt\n     */\n\n    /**\n     * Decrypt\n     */\n\n    /**\n     * Import\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg);\n      return normalizedAlgorithm.importKey(key);\n    }\n  }]);\n\n  return JWA;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = JWA;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof2(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(1);\n\nvar _require = __webpack_require__(0),\n    JSONDocument = _require.JSONDocument;\n\nvar JWTSchema = __webpack_require__(17);\nvar JWA = __webpack_require__(5);\nvar DataError = __webpack_require__(4);\n\n/**\n * Helper Functions\n * @ignore\n */\nfunction clean(input) {\n  return JSON.parse(JSON.stringify(input));\n}\n\n/**\n * JWT\n */\n\nvar JWT = function (_JSONDocument) {\n  _inherits(JWT, _JSONDocument);\n\n  /**\n   * constructor\n   */\n  function JWT(data) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JWT);\n\n    options.filter = options.filter || false;\n\n    var _this = _possibleConstructorReturn(this, (JWT.__proto__ || Object.getPrototypeOf(JWT)).call(this, data, options));\n\n    var type = data.type,\n        serialization = data.serialization;\n\n    Object.defineProperty(_this, 'type', { value: type, configurable: true, enumerable: false });\n    Object.defineProperty(_this, 'serialization', { value: serialization, configurable: true, enumerable: false });\n    return _this;\n  }\n\n  /**\n   * schema\n   */\n\n  _createClass(JWT, [{\n    key: 'isJWE',\n\n    /**\n     * isJWE\n     *\n     * @todo\n     */\n    value: function isJWE() {\n      return false;\n    }\n\n    /**\n     * resolveKeys\n     *\n     * @todo  This needs to be updated for use with the new API\n     */\n    // resolveKeys (jwks) {\n    //   let kid = this.header.kid\n\n    //   let keys, match\n\n    //   // treat an array as the \"keys\" property of a JWK Set\n    //   if (Array.isArray(jwks)) {\n    //     keys = jwks\n    //   }\n\n    //   // presence of keys indicates object is a JWK Set\n    //   if (jwks.keys) {\n    //     keys = jwks.keys\n    //   }\n\n    //   // wrap a plain object they is not a JWK Set in Array\n    //   if (!jwks.keys && typeof jwks === 'object') {\n    //     keys = [jwks]\n    //   }\n\n    //   // ensure there are keys to search\n    //   if (!keys) {\n    //     throw new DataError('Invalid JWK argument')\n    //   }\n\n    //   // match by \"kid\" or \"use\" header\n    //   if (kid) {\n    //     match = keys.find(jwk => jwk.kid === kid)\n    //   } else {\n    //     match = keys.find(jwk => jwk.use === 'sig')\n    //   }\n\n    //   // assign matching key to JWT and return a boolean\n    //   if (match) {\n    //     console.log(match)\n    //     this.key = match.cryptoKey\n    //     return true\n    //   } else {\n    //     return false\n    //   }\n    // }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token instance\n     *\n     * @param {...Object} data\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {\n        data[_key] = arguments[_key];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return this.sign(params);\n      }\n    }\n\n    /**\n     * sign\n     *\n     * @description\n     * Sign a JWT instance\n     *\n     * @todo import different types of key\n     *\n     * @param {...Object} data\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'sign',\n    value: function sign() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, data = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        data[_key2] = arguments[_key2];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      var payload = this.payload;\n      var protectedHeader = params.protected,\n          unprotectedHeader = params.header,\n          signature = params.signature,\n          signatures = params.signatures,\n          serialization = params.serialization,\n          cryptoKey = params.cryptoKey,\n          _params$validate = params.validate,\n          validate = _params$validate === undefined ? true : _params$validate,\n          result = params.result;\n\n      if (validate) {\n        var validation = this.validate();\n\n        if (!validation.valid) {\n          return Promise.reject(validation);\n        }\n      }\n\n      // Override serialization\n      if (serialization) {\n        Object.defineProperty(this, 'serialization', {\n          value: serialization,\n          enumerable: false,\n          configurable: true\n        });\n      }\n\n      // Normalize new flat signature\n      if (cryptoKey && !signature && (unprotectedHeader || protectedHeader)) {\n        var descriptor = {};\n\n        if (!protectedHeader && unprotectedHeader) {\n          descriptor.protected = unprotectedHeader;\n        } else {\n          descriptor.protected = protectedHeader;\n          descriptor.header = unprotectedHeader;\n        }\n\n        descriptor.cryptoKey = cryptoKey;\n\n        // Add to signatures array\n        if (signatures && Array.isArray(signatures)) {\n          signatures.push(descriptor);\n        } else {\n          signatures = [descriptor];\n        }\n      }\n\n      // Create signatures\n      var promises = [];\n      if (signatures && Array.isArray(signatures)) {\n        // Ignore ambiguous/invalid descriptors\n        promises = signatures.filter(function (descriptor) {\n          return descriptor.cryptoKey && !descriptor.signature;\n\n          // assemble and sign\n        }).map(function (descriptor) {\n          var protectedHeader = descriptor.protected,\n              unprotectedHeader = descriptor.header,\n              signature = descriptor.signature,\n              cryptoKey = descriptor.cryptoKey;\n          var alg = protectedHeader.alg;\n\n          // Encode signature content\n\n          var encodedHeader = base64url(JSON.stringify(protectedHeader));\n          var encodedPayload = base64url(JSON.stringify(payload));\n          var data = encodedHeader + '.' + encodedPayload;\n\n          return JWA.sign(alg, cryptoKey, data).then(function (signature) {\n            return { protected: protectedHeader, header: unprotectedHeader, signature: signature };\n          });\n        });\n      }\n\n      // Await signatures\n      return Promise.all(promises).then(function (signatures) {\n        if (signatures.length > 0) {\n          if (_this2.signatures && Array.isArray(_this2.signatures)) {\n            _this2.signatures = _this2.signatures.concat(signatures);\n          } else {\n            _this2.signatures = signatures;\n          }\n        }\n\n        if (!result || result === 'string') {\n          return _this2.serialize();\n        } else if (result === 'object' || result === 'instance') {\n          return _this2;\n        }\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a decoded JSON Web Token instance\n     *\n     * @todo jwk, jwkSet and pem key types\n     *\n     * @param {...Object} data\n     * @returns {Promise<Boolean|Object>}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      var _this3 = this;\n\n      for (var _len3 = arguments.length, data = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        data[_key3] = arguments[_key3];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n      var signatures = this.signatures,\n          payload = this.payload,\n          serialization = this.serialization;\n      var validate = params.validate,\n          result = params.result,\n          cryptoKey = params.cryptoKey,\n          cryptoKeys = params.cryptoKeys;\n\n      // Validate instance\n\n      if (validate) {\n        var validation = this.validate();\n\n        if (!validation.valid) {\n          throw new Error(validation);\n        }\n      }\n\n      // Encode payload\n      var encodedPayload = base64url(JSON.stringify(payload));\n\n      // Verify all signatures with a key present\n      var promises = signatures.map(function (descriptor, index) {\n\n        var key = void 0;\n        // Get manually mapped key\n        if (descriptor.cryptoKey) {\n          key = descriptor.cryptoKey;\n\n          // Get corresponding key\n        } else if (cryptoKeys && Array.isArray(cryptoKeys) && index < cryptoKeys.length && cryptoKeys[index]) {\n\n          key = cryptoKeys[index];\n\n          // Attempt to use the single key\n        } else if (cryptoKey) {\n          key = cryptoKey;\n\n          // No key to verify signature; ignore\n        } else {\n          return Promise.resolve(true);\n        }\n\n        var protectedHeader = descriptor.protected,\n            unprotectedHeader = descriptor.header,\n            signature = descriptor.signature;\n\n        // no signature to verify\n\n        if (!signature) {\n          return Promise.reject(new DataError('Missing signature(s)'));\n        }\n\n        var alg = protectedHeader.alg;\n\n        // Encode header and assemble signature verification data\n\n        var encodedHeader = base64url(JSON.stringify(protectedHeader));\n        var data = encodedHeader + '.' + encodedPayload;\n\n        // Verify signature and store result on the descriptor\n        return JWA.verify(alg, key, signature, data).then(function (verified) {\n          Object.defineProperty(signatures[index], 'verified', {\n            value: verified,\n            enumerable: false,\n            configurable: true\n          });\n          return verified;\n        });\n      });\n\n      // Await verification results\n      return Promise.all(promises).then(function (verified) {\n        verified = verified.reduce(function (prev, val) {\n          return prev ? val : false;\n        }, true);\n\n        Object.defineProperty(_this3, 'verified', {\n          value: verified,\n          enumerable: false,\n          configurable: true\n        });\n\n        if (!result || result === 'boolean') {\n          return verified;\n        } else if (result === 'object' || result === 'instance') {\n          return _this3;\n        }\n      });\n    }\n\n    /**\n     * toCompact\n     */\n\n  }, {\n    key: 'toCompact',\n    value: function toCompact() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      var protectedHeader = void 0,\n          signature = void 0;\n\n      // Signatures present\n      if (signatures && Array.isArray(signatures) && signatures.length > 0) {\n        protectedHeader = signatures[0].protected;\n        signature = signatures[0].signature;\n      }\n\n      if (!protectedHeader) {\n        throw new DataError('Protected header is required');\n      }\n\n      // Encode protected header and payload\n      var encodedPayload = base64url(JSON.stringify(payload));\n      var encodedHeader = base64url(JSON.stringify(protectedHeader));\n      var data = encodedHeader + '.' + encodedPayload;\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        // Return compact JWT with signature\n        if (signature) {\n          return data + '.' + signature;\n\n          // Return compact JWT without signature\n        } else {\n          return data + '.';\n        }\n      }\n    }\n\n    /**\n     * toFlattened\n     */\n\n  }, {\n    key: 'toFlattened',\n    value: function toFlattened() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      var protectedHeader = void 0,\n          unprotectedHeader = void 0,\n          signature = void 0;\n\n      // Signatures present\n      if (signatures && Array.isArray(signatures) && signatures.length > 0) {\n        protectedHeader = signatures[0].protected;\n        unprotectedHeader = signatures[0].header;\n        signature = signatures[0].signature;\n      }\n\n      if (!protectedHeader) {\n        throw new DataError('Protected header is required');\n      }\n\n      // Encode protected header and payload\n      var encodedPayload = base64url(JSON.stringify(payload));\n      var encodedHeader = base64url(JSON.stringify(protectedHeader));\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return JSON.stringify({\n          payload: encodedPayload,\n          header: unprotectedHeader,\n          protected: encodedHeader,\n          signature: signature\n        });\n      }\n    }\n\n    /**\n     * toGeneral\n     */\n\n  }, {\n    key: 'toGeneral',\n    value: function toGeneral() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      // Encode payload\n\n      var encodedPayload = base64url(JSON.stringify(payload));\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        // Return with signature\n        if (signatures) {\n\n          // Serialize signatures\n          var serializedSignatures = signatures.map(function (descriptor) {\n            var unprotectedHeader = descriptor.header,\n                protectedHeader = descriptor.protected,\n                signature = descriptor.signature;\n\n            // Encode protected header\n\n            var encodedHeader = base64url(JSON.stringify(protectedHeader));\n\n            return { header: unprotectedHeader, protected: encodedHeader, signature: signature };\n          });\n\n          return JSON.stringify({\n            payload: encodedPayload,\n            signatures: serializedSignatures\n          });\n\n          // Return without signatures\n        } else {\n          return JSON.stringify({ payload: encodedPayload });\n        }\n      }\n    }\n\n    /**\n     * toJWD\n     *\n     * @description\n     * Convert a JWT to a JWD\n     *\n     * @return {JWD}\n     */\n\n  }, {\n    key: 'toJWD',\n    value: function toJWD() {\n      var JWD = __webpack_require__(11);\n      return new JWD(this);\n    }\n\n    /**\n     * serialize\n     *\n     * @description\n     * Serialize a JWT instance to the preferred serialization\n     *\n     * @return {SerializedToken}\n     */\n\n  }, {\n    key: 'serialize',\n    value: function serialize() {\n      var serialization = this.serialization;\n\n      switch (serialization) {\n        case 'compact':\n          return this.toCompact();\n        case 'flattened':\n          return this.toFlattened();\n        case 'json':\n          return this.toGeneral();\n        case 'document':\n          return this.toJWD().toDocumentGeneral();\n        case 'flattened-document':\n          return this.toJWD().toDocumentFlattened();\n        default:\n          return this.toGeneral();\n      }\n    }\n  }], [{\n    key: 'decode',\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Token\n     *\n     * @param {String} token\n     * @returns {JWT}\n     */\n    value: function decode(token) {\n      if (typeof token !== 'string') {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Parse\n      if (token.startsWith('{')) {\n        try {\n          token = JSON.parse(token);\n        } catch (err) {\n          throw new DataError('Malformed JWT');\n        }\n      }\n\n      // Compact\n      if (typeof token === 'string') {\n        return this.fromCompact(token);\n      }\n\n      // JSON General\n      if (token.signatures) {\n        return this.fromGeneral(token);\n\n        // JSON Flattened\n      } else {\n        return this.fromFlattened(token);\n      }\n    }\n\n    /**\n     * fromCompact\n     *\n     * @description\n     * Deserialize a Compact JWT and instantiate an instance\n     *\n     * @param  {String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromCompact',\n    value: function fromCompact(data) {\n      var ExtendedJWT = this;\n      var protectedHeader = void 0,\n          payload = void 0,\n          signature = void 0;\n\n      // Parse\n      if (typeof data === 'string') {\n        var segments = data.split('.');\n\n        if (![3, 5].includes(segments.length)) {\n          throw new DataError('Malformed JWT');\n        }\n\n        // Decode base64url\n        if (segments.length === 3) {\n          try {\n            protectedHeader = JSON.parse(base64url.decode(segments[0]));\n            payload = JSON.parse(base64url.decode(segments[1]));\n            signature = segments[2];\n          } catch (err) {\n            throw new DataError('Malformed JWS');\n          }\n        }\n\n        if (segments.length === 5) {\n          // TODO JWE\n        }\n      }\n\n      // Sanity Check\n      if ((typeof protectedHeader === 'undefined' ? 'undefined' : _typeof(protectedHeader)) !== 'object' || protectedHeader === null || Array.isArray(protectedHeader)) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      // Normalize and return instance\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: [{ protected: protectedHeader, signature: signature }],\n        serialization: 'compact',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * fromFlattened\n     *\n     * @description\n     * Deserialize a JSON Flattened JWT and instantiate an instance\n     *\n     * @param  {Object|String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromFlattened',\n    value: function fromFlattened(data) {\n      var ExtendedJWT = this;\n      var protectedHeader = void 0,\n          payload = void 0;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWT');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Decode base64url\n      try {\n        payload = JSON.parse(base64url.decode(data.payload));\n        protectedHeader = JSON.parse(base64url.decode(data.protected));\n      } catch (err) {\n        throw new Error('Invalid JWT');\n      }\n\n      // Fetch decoded values\n      var _data = data,\n          unprotectedHeader = _data.header,\n          signature = _data.signature;\n\n      // Sanity Check\n\n      if ((typeof protectedHeader === 'undefined' ? 'undefined' : _typeof(protectedHeader)) !== 'object' || protectedHeader === null || Array.isArray(protectedHeader)) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      if (unprotectedHeader && ((typeof unprotectedHeader === 'undefined' ? 'undefined' : _typeof(unprotectedHeader)) !== 'object' || unprotectedHeader === null || Array.isArray(unprotectedHeader))) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      // Normalize and return instance\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: [{ protected: protectedHeader, header: unprotectedHeader, signature: signature }],\n        serialization: 'flattened',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * fromGeneral\n     *\n     * @description\n     * Deserialize a JSON General JWT and instantiate an instance\n     *\n     * @param  {Object|String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromGeneral',\n    value: function fromGeneral(data) {\n      var ExtendedJWT = this;\n      var payload = void 0,\n          signatures = void 0;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWT');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Signatures must be present and an array\n      if (!Array.isArray(data.signatures)) {\n        throw new DataError('JWT signatures property must be an array');\n      }\n\n      // Decode payload\n      try {\n        payload = JSON.parse(base64url.decode(data.payload));\n      } catch (err) {\n        throw new Error('Invalid JWT');\n      }\n\n      // Decode signatures\n      signatures = data.signatures.map(function (descriptor) {\n        var protectedHeader = descriptor.protected,\n            unprotectedHeader = descriptor.header,\n            signature = descriptor.signature;\n\n        var decodedHeader = void 0;\n\n        try {\n          decodedHeader = JSON.parse(base64url.decode(protectedHeader));\n        } catch (err) {\n          throw new DataError('Invalid JWT');\n        }\n\n        if (!decodedHeader || (typeof decodedHeader === 'undefined' ? 'undefined' : _typeof(decodedHeader)) !== 'object' || decodedHeader === null || Array.isArray(decodedHeader)) {\n          throw new DataError('JWT Protected Header must be an object');\n        }\n\n        if (unprotectedHeader && ((typeof unprotectedHeader === 'undefined' ? 'undefined' : _typeof(unprotectedHeader)) !== 'object' || unprotectedHeader === null || Array.isArray(unprotectedHeader))) {\n          throw new DataError('JWT Header must be an object');\n        }\n\n        return {\n          protected: decodedHeader,\n          header: unprotectedHeader,\n          signature: signature\n        };\n      });\n\n      // Normalize and return instance\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: signatures,\n        serialization: 'json',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * from\n     *\n     * @description\n     * Instanciate a JWT from an object descriptor\n     *\n     * @param {Object|String} data\n     * @param {String} [data.serialized] - Existing serialized JWT\n     *\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'from',\n    value: function from(data) {\n      var ExtendedJWT = this;\n\n      // Decode serialized token\n      if (typeof data === 'string' || data.serialized) {\n        return this.decode(data.serialized || data);\n      }\n\n      var payload = data.payload,\n          signatures = data.signatures,\n          serialization = data.serialization,\n          filter = data.filter;\n\n      if (!payload) {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Include compelete signature descriptors only\n      if (signatures && Array.isArray(signatures)) {\n        signatures = signatures.filter(function (descriptor) {\n          return !descriptor.cryptoKey || descriptor.signature;\n        });\n      } else {\n        signatures = [];\n      }\n\n      // Normalize existing flat signature\n      if (!data.cryptoKey && data.signature) {\n        var protectedHeader = data.protected,\n            unprotectedHeader = data.header,\n            signature = data.signature;\n\n        var descriptor = {};\n\n        if (!protectedHeader && unprotectedHeader) {\n          descriptor.protected = unprotectedHeader;\n        } else {\n          descriptor.protected = protectedHeader;\n          descriptor.header = unprotectedHeader;\n        }\n\n        descriptor.signature = signature;\n\n        if (signatures && Array.isArray(signatures)) {\n          signatures.unshift(descriptor);\n        } else {\n          signatures = [descriptor];\n        }\n      }\n\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: signatures,\n        serialization: serialization,\n        type: 'JWS'\n      }), { filter: filter || ExtendedJWT.name !== 'JWT' && ExtendedJWT.name !== 'JWD' });\n    }\n\n    /**\n     * sign\n     *\n     * @description\n     * Sign a JSON Web Token\n     *\n     * @params {...Object} data - Token data\n     *\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'sign',\n    value: function sign() {\n      for (var _len4 = arguments.length, data = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        data[_key4] = arguments[_key4];\n      }\n\n      // Shallow merge data\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      // Try decode\n      var instance = void 0;\n      try {\n        instance = this.from(params);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      return instance.sign(params);\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token\n     *\n     * @param {...Object} data\n     *\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      for (var _len5 = arguments.length, data = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        data[_key5] = arguments[_key5];\n      }\n\n      // Shallow merge data\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      // Try decode\n      var instance = void 0;\n      try {\n        instance = this.from(params);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      return instance.encode(params);\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Decode and verify a JSON Web Token\n     *\n     * @param {...Object} data\n     * @returns {Promise<JWT>}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      for (var _len6 = arguments.length, data = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        data[_key6] = arguments[_key6];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n      var serialized = params.serialized;\n\n      if (!serialized) {\n        throw new Error('JWT input required');\n      }\n\n      // Try decode\n      var instance = void 0;\n      try {\n        instance = this.from(serialized);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      return instance.verify(params);\n    }\n  }, {\n    key: 'schema',\n    get: function get() {\n      return JWTSchema;\n    }\n  }]);\n\n  return JWT;\n}(JSONDocument);\n\n/**\n * Export\n */\n\nmodule.exports = JWT;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar TextEncoder = global.TextEncoder ? global.TextEncoder // browser\n: __webpack_require__(40).TextEncoder; // node shim\nmodule.exports = TextEncoder;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(22)))\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\nmodule.exports = JSONPointer;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = crypto;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * NotSupportedError\n */\nvar NotSupportedError = function (_Error) {\n  _inherits(NotSupportedError, _Error);\n\n  function NotSupportedError(alg) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this.message = alg + \" is not a supported algorithm\";\n    return _this;\n  }\n\n  return NotSupportedError;\n}(Error);\n\n/**\n * Export\n */\n\nmodule.exports = NotSupportedError;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof2(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/**\n * Dependencies\n * @ignore\n */\nvar base64url = __webpack_require__(1);\nvar JWT = __webpack_require__(6);\nvar DataError = __webpack_require__(4);\n\n/**\n * Helper Functions\n * @ignore\n */\nfunction clean(input) {\n  return JSON.parse(JSON.stringify(input));\n}\n\n/**\n * JWD\n */\n\nvar JWD = function (_JWT) {\n  _inherits(JWD, _JWT);\n\n  function JWD() {\n    _classCallCheck(this, JWD);\n\n    return _possibleConstructorReturn(this, (JWD.__proto__ || Object.getPrototypeOf(JWD)).apply(this, arguments));\n  }\n\n  _createClass(JWD, [{\n    key: 'toDocumentFlattened',\n\n    /**\n     * toDocumentFlattened\n     */\n    value: function toDocumentFlattened() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      var protectedHeader = void 0,\n          unprotectedHeader = void 0,\n          signature = void 0;\n\n      // Signatures present\n      if (signatures && Array.isArray(signatures) && signatures.length > 0) {\n        protectedHeader = signatures[0].protected;\n        unprotectedHeader = signatures[0].header;\n        signature = signatures[0].signature;\n      }\n\n      if (!protectedHeader) {\n        throw new DataError('Protected header is required');\n      }\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return JSON.stringify({\n          payload: payload,\n          header: unprotectedHeader,\n          protected: protectedHeader,\n          signature: signature\n        });\n      }\n    }\n\n    /**\n     * toDocumentGeneral\n     */\n\n  }, {\n    key: 'toDocumentGeneral',\n    value: function toDocumentGeneral() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return JSON.stringify({ payload: payload, signatures: signatures });\n      }\n    }\n\n    /**\n     * toJWT\n     *\n     * @description\n     * Convert a JWD to a JWT\n     *\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'toJWT',\n    value: function toJWT() {\n      var JWT = __webpack_require__(6);\n      return new JWT(this);\n    }\n\n    /**\n     * serialize\n     *\n     * @description\n     * Serialize a JWD instance to the preferred serialization\n     *\n     * @return {SerializedToken}\n     */\n\n  }, {\n    key: 'serialize',\n    value: function serialize() {\n      var serialization = this.serialization;\n\n      switch (serialization) {\n        case 'compact':\n          return this.toJWT().toCompact();\n        case 'flattened':\n          return this.toJWT().toFlattened();\n        case 'json':\n          return this.toJWT().toGeneral();\n        case 'document':\n          return this.toDocumentGeneral();\n        case 'flattened-document':\n          return this.toDocumentFlattened();\n        default:\n          return this.toDocumentGeneral();\n      }\n    }\n  }], [{\n    key: 'decode',\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Document\n     *\n     * @param {String} token\n     *\n     * @returns {JWT}\n     */\n    value: function decode(token) {\n      if (typeof token !== 'string') {\n        throw new DataError('Invalid JWD');\n      }\n\n      if (!token.startsWith('{')) {\n        throw new DataError('Malformed JWD');\n      }\n\n      // Parse\n      try {\n        token = JSON.parse(token);\n      } catch (err) {\n        throw new DataError('Malformed JWD');\n      }\n\n      // Document General\n      if (token.signatures) {\n        return this.fromDocumentGeneral(token);\n\n        // Document Flattened\n      } else {\n        return this.fromDocumentFlattened(token);\n      }\n    }\n\n    /**\n     * fromDocumentFlattened\n     *\n     * @description\n     * Deserialize a Compact JWT and instantiate an instance\n     *\n     * @param  {String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromDocumentFlattened',\n    value: function fromDocumentFlattened(data) {\n      var ExtendedJWD = this;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWD');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWD');\n      }\n\n      var _data = data,\n          protectedHeader = _data.protected,\n          unprotectedHeader = _data.header,\n          payload = _data.payload,\n          signature = _data.signature;\n\n      // Sanity Check\n\n      if ((typeof protectedHeader === 'undefined' ? 'undefined' : _typeof(protectedHeader)) !== 'object' || protectedHeader === null || Array.isArray(protectedHeader)) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      if (unprotectedHeader && ((typeof unprotectedHeader === 'undefined' ? 'undefined' : _typeof(unprotectedHeader)) !== 'object' || unprotectedHeader === null || Array.isArray(unprotectedHeader))) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      // Normalize and return instance\n      return new ExtendedJWD(clean({\n        payload: payload,\n        signatures: [{ protected: protectedHeader, header: unprotectedHeader, signature: signature }],\n        serialization: 'document-flattened',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * fromDocumentGeneral\n     *\n     * @description\n     * Deserialize a General JWD and instantiate an instance\n     *\n     * @param  {String} data\n     * @return {JWD}\n     */\n\n  }, {\n    key: 'fromDocumentGeneral',\n    value: function fromDocumentGeneral(data) {\n      var ExtendedJWD = this;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWD');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWD');\n      }\n\n      // Signatures must be present and an array\n      if (!Array.isArray(data.signatures)) {\n        throw new DataError('JWD signatures property must be an array');\n      }\n\n      var _data2 = data,\n          payload = _data2.payload,\n          signatures = _data2.signatures;\n\n      // Normalize and return instance\n\n      return new ExtendedJWD(clean({\n        payload: payload,\n        signatures: signatures,\n        serialization: 'document',\n        type: 'JWS'\n      }));\n    }\n  }]);\n\n  return JWD;\n}(JWT);\n\n/**\n * Export\n */\n\nmodule.exports = JWD;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(0),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSchema = __webpack_require__(3);\nvar JWA = __webpack_require__(5);\n\n/**\n * JWK Class\n */\n\nvar JWK = function (_JSONDocument) {\n  _inherits(JWK, _JSONDocument);\n\n  function JWK() {\n    _classCallCheck(this, JWK);\n\n    return _possibleConstructorReturn(this, (JWK.__proto__ || Object.getPrototypeOf(JWK)).apply(this, arguments));\n  }\n\n  _createClass(JWK, null, [{\n    key: 'importKey',\n\n    /**\n     * importKey\n     *\n     * TODO:\n     * - should this be on JWA?\n     */\n    value: function importKey(jwk) {\n      return JWA.importKey(jwk);\n    }\n  }, {\n    key: 'schema',\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return JWKSchema;\n    }\n  }]);\n\n  return JWK;\n}(JSONDocument);\n\n/**\n * Export\n */\n\nmodule.exports = JWK;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * Base64URLSchema\n */\n\nvar Base64URLSchema = new JSONSchema({\n  type: 'string',\n  format: 'base64url'\n});\n\n/**\n * Export\n */\nmodule.exports = Base64URLSchema;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar JWKSchema = __webpack_require__(3);\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JOSEHeaderSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-5\n *\n * 5.  JOSE Header\n *\n *   For a JWT object, the members of the JSON object represented by the\n *   JOSE Header describe the cryptographic operations applied to the JWT\n *   and optionally, additional properties of the JWT.  Depending upon\n *   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE\n *   Header values apply.\n */\n\nvar JOSEHeaderSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * typ\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.1\n     *\n     * 5.1.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter defined by [JWS] and [JWE] is used\n     *   by JWT applications to declare the media type [IANA.MediaTypes] of\n     *   this complete JWT.  This is intended for use by the JWT application\n     *   when values that are not JWTs could also be present in an application\n     *   data structure that can contain a JWT object; the application can use\n     *   this value to disambiguate among the different kinds of objects that\n     *   might be present.  It will typically not be used by applications when\n     *   it is already known that the object is a JWT.  This parameter is\n     *   ignored by JWT implementations; any processing of this parameter is\n     *   performed by the JWT application.  If present, it is RECOMMENDED that\n     *   its value be \"JWT\" to indicate that this object is a JWT.  While\n     *   media type names are not case sensitive, it is RECOMMENDED that \"JWT\"\n     *   always be spelled using uppercase characters for compatibility with\n     *   legacy implementations.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.9\n     *\n     * 4.1.9.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter is used by JWS applications to\n     *   declare the media type [IANA.MediaTypes] of this complete JWS.  This\n     *   is intended for use by the application when more than one kind of\n     *   object could be present in an application data structure that can\n     *   contain a JWS; the application can use this value to disambiguate\n     *   among the different kinds of objects that might be present.  It will\n     *   typically not be used by applications when the kind of object is\n     *   already known.  This parameter is ignored by JWS implementations; any\n     *   processing of this parameter is performed by the JWS application.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"typ\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"typ\" value not containing a\n     *   '/'.  For instance, a \"typ\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     *   The \"typ\" value \"JOSE\" can be used by applications to indicate that\n     *   this object is a JWS or JWE using the JWS Compact Serialization or\n     *   the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be\n     *   used by applications to indicate that this object is a JWS or JWE\n     *   using the JWS JSON Serialization or the JWE JSON Serialization.\n     *   Other type values can also be used by applications.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.11\n     *\n     * 4.1.11.  \"typ\" (Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"typ\" Header Parameter defined in Section 4.1.9 of [JWS], except\n     *   that the type is that of this complete JWE.\n     */\n    typ: {\n      type: 'string'\n    },\n\n    /**\n     * cty\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.2\n     *\n     * 5.2.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter defined by [JWS] and [JWE]\n     *   is used by this specification to convey structural information about\n     *   the JWT.\n     *\n     *   In the normal case in which nested signing or encryption operations\n     *   are not employed, the use of this Header Parameter is NOT\n     *   RECOMMENDED.  In the case that nested signing or encryption is\n     *   employed, this Header Parameter MUST be present; in this case, the\n     *   value MUST be \"JWT\", to indicate that a Nested JWT is carried in this\n     *   JWT.  While media type names are not case sensitive, it is\n     *   RECOMMENDED that \"JWT\" always be spelled using uppercase characters\n     *   for compatibility with legacy implementations.  See Appendix A.2 for\n     *   an example of a Nested JWT.\n     *\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.10\n     *\n     * 4.1.10.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter is used by JWS applications\n     *   to declare the media type [IANA.MediaTypes] of the secured content\n     *   (the payload).  This is intended for use by the application when more\n     *   than one kind of object could be present in the JWS Payload; the\n     *   application can use this value to disambiguate among the different\n     *   kinds of objects that might be present.  It will typically not be\n     *   used by applications when the kind of object is already known.  This\n     *   parameter is ignored by JWS implementations; any processing of this\n     *   parameter is performed by the JWS application.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"cty\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"cty\" value not containing a\n     *   '/'.  For instance, a \"cty\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.12\n     *\n     * 4.1.12.  \"cty\" (Content Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"cty\" Header Parameter defined in Section 4.1.10 of [JWS], except\n     *   that the type is that of the secured content (the plaintext).\n     */\n    cty: {\n      type: 'string',\n      enum: ['JWT', 'JWD']\n    },\n\n    /**\n     * alg\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   The \"alg\" (algorithm) Header Parameter identifies the cryptographic\n     *   algorithm used to secure the JWS.  The JWS Signature value is not\n     *   valid if the \"alg\" value does not represent a supported algorithm or\n     *   if there is not a key for use with that algorithm associated with the\n     *   party that digitally signed or MACed the content.  \"alg\" values\n     *   should either be registered in the IANA \"JSON Web Signature and\n     *   Encryption Algorithms\" registry established by [JWA] or be a value\n     *   that contains a Collision-Resistant Name.  The \"alg\" value is a case-\n     *   sensitive ASCII string containing a StringOrURI value.  This Header\n     *   Parameter MUST be present and MUST be understood and processed by\n     *   implementations.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 3.1 of [JWA].\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"alg\" Header Parameter defined in Section 4.1.1 of [JWS], except\n     *   that the Header Parameter identifies the cryptographic algorithm used\n     *   to encrypt or determine the value of the CEK.  The encrypted content\n     *   is not usable if the \"alg\" value does not represent a supported\n     *   algorithm, or if the recipient does not have a key that can be used\n     *   with that algorithm.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 4.1 of [JWA].\n     */\n    alg: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * jku\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.2\n     *\n     * 4.1.2.  \"jku\" (JWK Set URL) Header Parameter (JWS)\n     *\n     *   The \"jku\" (JWK Set URL) Header Parameter is a URI [RFC3986] that\n     *   refers to a resource for a set of JSON-encoded public keys, one of\n     *   which corresponds to the key used to digitally sign the JWS.  The\n     *   keys MUST be encoded as a JWK Set [JWK].  The protocol used to\n     *   acquire the resource MUST provide integrity protection; an HTTP GET\n     *   request to retrieve the JWK Set MUST use Transport Layer Security\n     *   (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n     *   validated, as per Section 6 of RFC 6125 [RFC6125].  Also, see\n     *   Section 8 on TLS requirements.  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.4\n     *\n     * 4.1.4.  \"jku\" (JWK Set URL) Header Parameter (JWE)\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jku\" Header Parameter defined in Section 4.1.2 of [JWS], except\n     *   that the JWK Set resource contains the public key to which the JWE\n     *   was encrypted; this can be used to determine the private key needed\n     *   to decrypt the JWE.\n     */\n    jku: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * jwk\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.3\n     *\n     * 4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   The \"jwk\" (JSON Web Key) Header Parameter is the public key that\n     *   corresponds to the key used to digitally sign the JWS.  This key is\n     *   represented as a JSON Web Key [JWK].  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.5\n     *\n     * 4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jwk\" Header Parameter defined in Section 4.1.3 of [JWS], except\n     *   that the key is the public key to which the JWE was encrypted; this\n     *   can be used to determine the private key needed to decrypt the JWE.\n     */\n    //jwk: JWKSchema,\n\n    /**\n     * kid\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.4\n     *\n     * 4.1.4.  \"kid\" (Key ID) Header Parameter\n     *\n     *   The \"kid\" (key ID) Header Parameter is a hint indicating which key\n     *   was used to secure the JWS.  This parameter allows originators to\n     *   explicitly signal a change of key to recipients.  The structure of\n     *   the \"kid\" value is unspecified.  Its value MUST be a case-sensitive\n     *   string.  Use of this Header Parameter is OPTIONAL.\n     *\n     *   When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n     *   parameter value.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.6\n     *\n     * 4.1.6.  \"kid\" (Key ID) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"kid\" Header Parameter defined in Section 4.1.4 of [JWS], except\n     *   that the key hint references the public key to which the JWE was\n     *   encrypted; this can be used to determine the private key needed to\n     *   decrypt the JWE.  This parameter allows originators to explicitly\n     *   signal a change of key to JWE recipients.\n     */\n    kid: {\n      type: 'string'\n    },\n\n    /**\n     * x5u\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.5\n     *\n     * 4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   The \"x5u\" (X.509 URL) Header Parameter is a URI [RFC3986] that refers\n     *   to a resource for the X.509 public key certificate or certificate\n     *   chain [RFC5280] corresponding to the key used to digitally sign the\n     *   JWS.  The identified resource MUST provide a representation of the\n     *   certificate or certificate chain that conforms to RFC 5280 [RFC5280]\n     *   in PEM-encoded form, with each certificate delimited as specified in\n     *   Section 6.1 of RFC 4945 [RFC4945].  The certificate containing the\n     *   public key corresponding to the key used to digitally sign the JWS\n     *   MUST be the first certificate.  This MAY be followed by additional\n     *   certificates, with each subsequent certificate being the one used to\n     *   certify the previous one.  The protocol used to acquire the resource\n     *   MUST provide integrity protection; an HTTP GET request to retrieve\n     *   the certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n     *   the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n     *   Also, see Section 8 on TLS requirements.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.7\n     *\n     * 4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5u\" Header Parameter defined in Section 4.1.5 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5u: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * x5c\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.6\n     *\n     * 4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   The \"x5c\" (X.509 certificate chain) Header Parameter contains the\n     *   X.509 public key certificate or certificate chain [RFC5280]\n     *   corresponding to the key used to digitally sign the JWS.  The\n     *   certificate or certificate chain is represented as a JSON array of\n     *   certificate value strings.  Each string in the array is a\n     *   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER\n     *   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n     *   the public key corresponding to the key used to digitally sign the\n     *   JWS MUST be the first certificate.  This MAY be followed by\n     *   additional certificates, with each subsequent certificate being the\n     *   one used to certify the previous one.  The recipient MUST validate\n     *   the certificate chain according to RFC 5280 [RFC5280] and consider\n     *   the certificate or certificate chain to be invalid if any validation\n     *   failure occurs.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.8\n     *\n     * 4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5c\" Header Parameter defined in Section 4.1.6 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5c: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'base64'\n      }\n    },\n\n    /**\n     * x5t\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.7\n     *\n     * 4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   The \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n     *   base64url-encoded SHA-1 thumbprint (a.k.a. digest) of the DER\n     *   encoding of the X.509 certificate [RFC5280] corresponding to the key\n     *   used to digitally sign the JWS.  Note that certificate thumbprints\n     *   are also sometimes known as certificate fingerprints.  Use of this\n     *   Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.9\n     *\n     * 4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t\" Header Parameter defined in Section 4.1.7 of [JWS], except\n     *   that the certificate referenced by the thumbprint contains the public\n     *   key to which the JWE was encrypted; this can be used to determine the\n     *   private key needed to decrypt the JWE.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     */\n    x5t: {\n      type: 'string',\n      format: 'base64url'\n    },\n\n    /**\n     * x5t#S256\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.8\n     *\n     * 4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *         Parameter\n     *\n     *   The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n     *   Parameter is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n     *   of the DER encoding of the X.509 certificate [RFC5280] corresponding\n     *   to the key used to digitally sign the JWS.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.10\n     *\n     * 4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *          Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n     *   except that the certificate referenced by the thumbprint contains the\n     *   public key to which the JWE was encrypted; this can be used to\n     *   determine the private key needed to decrypt the JWE.  Note that\n     *   certificate thumbprints are also sometimes known as certificate\n     *   fingerprints.\n     */\n    //'x5t#S256': {\n    //  type: 'string',\n    //  format: 'base64url'\n    //},\n\n    /**\n     * crit\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.11\n     *\n     * 4.1.11.  \"crit\" (Critical) Header Parameter\n     *\n     *   The \"crit\" (critical) Header Parameter indicates that extensions to\n     *   this specification and/or [JWA] are being used that MUST be\n     *   understood and processed.  Its value is an array listing the Header\n     *   Parameter names present in the JOSE Header that use those extensions.\n     *   If any of the listed extension Header Parameters are not understood\n     *   and supported by the recipient, then the JWS is invalid.  Producers\n     *   MUST NOT include Header Parameter names defined by this specification\n     *   or [JWA] for use with JWS, duplicate names, or names that do not\n     *   occur as Header Parameter names within the JOSE Header in the \"crit\"\n     *   list.  Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n     *   value.  Recipients MAY consider the JWS to be invalid if the critical\n     *   list contains any Header Parameter names defined by this\n     *   specification or [JWA] for use with JWS or if any other constraints\n     *   on its use are violated.  When used, this Header Parameter MUST be\n     *   integrity protected; therefore, it MUST occur only within the JWS\n     *   Protected Header.  Use of this Header Parameter is OPTIONAL.  This\n     *   Header Parameter MUST be understood and processed by implementations.\n     *\n     *   An example use, along with a hypothetical \"exp\" (expiration time)\n     *   field is:\n     *\n     *     {\"alg\":\"ES256\",\n     *     \"crit\":[\"exp\"],\n     *     \"exp\":1363284000\n     *     }\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.13\n     *\n     *   4.1.13.  \"crit\" (Critical) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"crit\" Header Parameter defined in Section 4.1.11 of [JWS],\n     *   except that Header Parameters for a JWE are being referred to, rather\n     *   than Header Parameters for a JWS.\n     */\n    crit: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      minItems: 1\n    },\n\n    /**\n     * enc\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.2\n     *\n     * 4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n     *\n     *   The \"enc\" (encryption algorithm) Header Parameter identifies the\n     *   content encryption algorithm used to perform authenticated encryption\n     *   on the plaintext to produce the ciphertext and the Authentication\n     *   Tag.  This algorithm MUST be an AEAD algorithm with a specified key\n     *   length.  The encrypted content is not usable if the \"enc\" value does\n     *   not represent a supported algorithm.  \"enc\" values should either be\n     *   registered in the IANA \"JSON Web Signature and Encryption Algorithms\"\n     *   registry established by [JWA] or be a value that contains a\n     *   Collision-Resistant Name.  The \"enc\" value is a case-sensitive ASCII\n     *   string containing a StringOrURI value.  This Header Parameter MUST be\n     *   present and MUST be understood and processed by implementations.\n     *\n     *   A list of defined \"enc\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 5.1 of [JWA].\n     */\n    enc: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * zip\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.3\n     *\n     * 4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n     *\n     *   The \"zip\" (compression algorithm) applied to the plaintext before\n     *   encryption, if any.  The \"zip\" value defined by this specification\n     *   is:\n     *\n     *   o  \"DEF\" - Compression with the DEFLATE [RFC1951] algorithm\n     *\n     *   Other values MAY be used.  Compression algorithm values can be\n     *   registered in the IANA \"JSON Web Encryption Compression Algorithms\"\n     *   registry established by [JWA].  The \"zip\" value is a case-sensitive\n     *   string.  If no \"zip\" parameter is present, no compression is applied\n     *   to the plaintext before encryption.  When used, this Header Parameter\n     *   MUST be integrity protected; therefore, it MUST occur only within the\n     *   JWE Protected Header.  Use of this Header Parameter is OPTIONAL.\n     *   This Header Parameter MUST be understood and processed by\n     *   implementations.\n     */\n    zip: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JOSEHeaderSchema;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\nvar JWKSchema = __webpack_require__(3);\n\n/**\n * JWKSetSchema\n */\nvar JWKSetSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: JWKSchema\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSetSchema;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTClaimsSetSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-4\n *\n * 4.  JWT Claims\n *\n *   The JWT Claims Set represents a JSON object whose members are the\n *   claims conveyed by the JWT.  The Claim Names within a JWT Claims Set\n *   MUST be unique; JWT parsers MUST either reject JWTs with duplicate\n *   Claim Names or use a JSON parser that returns only the lexically last\n *   duplicate member name, as specified in Section 15.12 (\"The JSON\n *   Object\") of ECMAScript 5.1 [ECMAScript].\n *\n *   The set of claims that a JWT must contain to be considered valid is\n *   context dependent and is outside the scope of this specification.\n *   Specific applications of JWTs will require implementations to\n *   understand and process some claims in particular ways.  However, in\n *   the absence of such requirements, all claims that are not understood\n *   by implementations MUST be ignored.\n *\n *   There are three classes of JWT Claim Names: Registered Claim Names,\n *   Public Claim Names, and Private Claim Names.\n */\n\nvar JWTClaimsSetSchema = new JSONSchema({\n  // additionalProperties: true,\n  properties: {\n\n    /**\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1\n     *\n     * 4.1.  Registered Claim Names\n     *\n     *   The following Claim Names are registered in the IANA \"JSON Web Token\n     *   Claims\" registry established by Section 10.1.  None of the claims\n     *   defined below are intended to be mandatory to use or implement in all\n     *   cases, but rather they provide a starting point for a set of useful,\n     *   interoperable claims.  Applications using JWTs should define which\n     *   specific claims they use and when they are required or optional.  All\n     *   the names are short because a core goal of JWTs is for the\n     *   representation to be compact.\n     */\n\n    /**\n     * iss\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.1\n     *\n     * 4.1.1.  \"iss\" (Issuer) Claim\n     *\n     *   The \"iss\" (issuer) claim identifies the principal that issued the\n     *   JWT.  The processing of this claim is generally application specific.\n     *   The \"iss\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    iss: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * sub\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.2\n     *\n     * 4.1.2.  \"sub\" (Subject) Claim\n     *\n     *   The \"sub\" (subject) claim identifies the principal that is the\n     *   subject of the JWT.  The claims in a JWT are normally statements\n     *   about the subject.  The subject value MUST either be scoped to be\n     *   locally unique in the context of the issuer or be globally unique.\n     *   The processing of this claim is generally application specific.  The\n     *   \"sub\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    sub: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * aud\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.3\n     *\n     * 4.1.3.  \"aud\" (Audience) Claim\n     *\n     *   The \"aud\" (audience) claim identifies the recipients that the JWT is\n     *   intended for.  Each principal intended to process the JWT MUST\n     *   identify itself with a value in the audience claim.  If the principal\n     *   processing the claim does not identify itself with a value in the\n     *   \"aud\" claim when this claim is present, then the JWT MUST be\n     *   rejected.  In the general case, the \"aud\" value is an array of case-\n     *   sensitive strings, each containing a StringOrURI value.  In the\n     *   special case when the JWT has one audience, the \"aud\" value MAY be a\n     *   single case-sensitive string containing a StringOrURI value.  The\n     *   interpretation of audience values is generally application specific.\n     *   Use of this claim is OPTIONAL.\n     */\n    aud: {\n      type: ['array', 'string'],\n      format: 'StringOrURI',\n      items: {\n        format: 'StringOrURI'\n      }\n    },\n\n    /**\n     * exp\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.4\n     *\n     * 4.1.4.  \"exp\" (Expiration Time) Claim\n     *\n     *   The \"exp\" (expiration time) claim identifies the expiration time on\n     *   or after which the JWT MUST NOT be accepted for processing.  The\n     *   processing of the \"exp\" claim requires that the current date/time\n     *   MUST be before the expiration date/time listed in the \"exp\" claim.\n     *\n     *   Implementers MAY provide for some small leeway, usually no more than\n     *   a few minutes, to account for clock skew.  Its value MUST be a number\n     *   containing a NumericDate value.  Use of this claim is OPTIONAL.\n     *\n     */\n    exp: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * nbf\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.5\n     *\n     * 4.1.5.  \"nbf\" (Not Before) Claim\n     *\n     *   The \"nbf\" (not before) claim identifies the time before which the JWT\n     *   MUST NOT be accepted for processing.  The processing of the \"nbf\"\n     *   claim requires that the current date/time MUST be after or equal to\n     *   the not-before date/time listed in the \"nbf\" claim.  Implementers MAY\n     *   provide for some small leeway, usually no more than a few minutes, to\n     *   account for clock skew.  Its value MUST be a number containing a\n     *   NumericDate value.  Use of this claim is OPTIONAL.\n     */\n    nbf: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * iat\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.6\n     *\n     * 4.1.6.  \"iat\" (Issued At) Claim\n     *\n     *   The \"iat\" (issued at) claim identifies the time at which the JWT was\n     *   issued.  This claim can be used to determine the age of the JWT.  Its\n     *   value MUST be a number containing a NumericDate value.  Use of this\n     *   claim is OPTIONAL.\n     */\n    iat: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * jti\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.7\n     *\n     * 4.1.7.  \"jti\" (JWT ID) Claim\n     *\n     *   The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n     *   The identifier value MUST be assigned in a manner that ensures that\n     *   there is a negligible probability that the same value will be\n     *   accidentally assigned to a different data object; if the application\n     *   uses multiple issuers, collisions MUST be prevented among values\n     *   produced by different issuers as well.  The \"jti\" claim can be used\n     *   to prevent the JWT from being replayed.  The \"jti\" value is a case-\n     *   sensitive string.  Use of this claim is OPTIONAL.\n     */\n    jti: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTClaimsSetSchema;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar Base64URLSchema = __webpack_require__(13);\nvar JWTClaimsSetSchema = __webpack_require__(16);\nvar JOSEHeaderSchema = __webpack_require__(14);\n\nvar _require = __webpack_require__(0),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTSchema\n *\n * @description\n * This schema represents all the things a deserialized JWT can be, i.e.,\n * either a JWS or JWE, and any serialization of them. Validation of well-\n * formedness for a given serialization is accomplished at the time of\n * encoding.\n */\n\nvar JWTSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * iv\n     */\n    iv: Base64URLSchema,\n\n    /**\n     * aad\n     */\n    aad: Base64URLSchema,\n\n    /**\n     * ciphertext\n     */\n    ciphertext: Base64URLSchema,\n\n    /**\n     * tag\n     */\n    tag: Base64URLSchema,\n\n    /**\n     * recipients\n     */\n    recipients: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          header: JOSEHeaderSchema,\n          encrypted_key: Base64URLSchema\n        }\n      }\n    },\n\n    /**\n     * payload\n     */\n    payload: JWTClaimsSetSchema,\n\n    /**\n     * signatures\n     */\n    signatures: {\n      type: 'array'\n      // items: {\n      //   type: 'object',\n      //   properties: {\n      //     protected: JOSEHeaderSchema,\n      //     header: JOSEHeaderSchema,\n      //     signature: Base64URLSchema\n      //   }\n      // }\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTSchema;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = Formats.initialize();\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Initializer\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JSONPointer = __webpack_require__(8);\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\nmodule.exports = JSONPatch;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar formats = __webpack_require__(18);\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = Validator;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\n\nvar JWA = __webpack_require__(5);\nvar JWK = __webpack_require__(12);\nvar JWKSet = __webpack_require__(31);\nvar JWT = __webpack_require__(6);\nvar JWD = __webpack_require__(11);\nvar Base64URLSchema = __webpack_require__(13);\nvar JOSEHeaderSchema = __webpack_require__(14);\nvar JWKSchema = __webpack_require__(3);\nvar JWKSetSchema = __webpack_require__(15);\nvar JWTClaimsSetSchema = __webpack_require__(16);\nvar JWTSchema = __webpack_require__(17);\n\n/**\n * Export\n */\nmodule.exports = {\n  JWA: JWA,\n  JWK: JWK,\n  JWKSet: JWKSet,\n  JWT: JWT,\n  JWD: JWD,\n  Base64URLSchema: Base64URLSchema,\n  JOSEHeaderSchema: JOSEHeaderSchema,\n  JWKSchema: JWKSchema,\n  JWKSetSchema: JWKSetSchema,\n  JWTClaimsSetSchema: JWTClaimsSetSchema,\n  JWTSchema: JWTSchema\n};\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar base64url = __webpack_require__(1);\nvar crypto = __webpack_require__(9);\nvar TextEncoder = __webpack_require__(7);\n\n/**\n * ECDSA\n */\n\nvar ECDSA = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function ECDSA(params) {\n    _classCallCheck(this, ECDSA);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n  _createClass(ECDSA, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return ECDSA;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = ECDSA;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar base64url = __webpack_require__(1);\nvar crypto = __webpack_require__(9);\nvar TextEncoder = __webpack_require__(7);\n\n/**\n * HMAC with SHA-2 Functions\n */\n\nvar HMAC = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  function HMAC(params) {\n    _classCallCheck(this, HMAC);\n\n    this.params = params;\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO: validate key length\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {string} signature\n     * @param {string} data\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * Assert Sufficient Key Length\n     *\n     * @description Assert that the key length is sufficient\n     * @param {string} key\n     */\n\n  }, {\n    key: 'assertSufficientKeyLength',\n    value: function assertSufficientKeyLength(key) {\n      if (key.length < this.bitlength) {\n        throw new Error('The key is too short.');\n      }\n    }\n  }]);\n\n  return HMAC;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = HMAC;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar base64url = __webpack_require__(1);\nvar crypto = __webpack_require__(9);\nvar TextEncoder = __webpack_require__(7);\n\n/**\n * RSASSA-PKCS1-v1_5\n */\n\nvar RSASSA_PKCS1_v1_5 = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function RSASSA_PKCS1_v1_5(params) {\n    _classCallCheck(this, RSASSA_PKCS1_v1_5);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n  _createClass(RSASSA_PKCS1_v1_5, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO\n      //if (!this.sufficientKeySize()) {\n      //  return Promise.reject(\n      //    new Error(\n      //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n      //    )\n      //  )\n      //}\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return RSASSA_PKCS1_v1_5;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = RSASSA_PKCS1_v1_5;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Dependencies\n */\nvar NotSupportedError = __webpack_require__(10);\n\n/**\n * Operations\n */\nvar operations = ['sign', 'verify', 'encrypt', 'decrypt', 'importKey'];\n\n/**\n * SupportedAlgorithms\n */\n\nvar SupportedAlgorithms = function () {\n\n  /**\n   * constructor\n   */\n  function SupportedAlgorithms() {\n    var _this = this;\n\n    _classCallCheck(this, SupportedAlgorithms);\n\n    operations.forEach(function (op) {\n      _this[op] = {};\n    });\n  }\n\n  /**\n   * Supported Operations\n   */\n\n  _createClass(SupportedAlgorithms, [{\n    key: 'define',\n\n    /**\n     * define\n     *\n     * @description\n     * Register Web Crypto API algorithm parameter for an algorithm\n     * and operation.\n     *\n     * @param {string} alg\n     * @param {string} op\n     * @param {Object} argument\n     */\n    value: function define(alg, op, argument) {\n      var registeredAlgorithms = this[op];\n      registeredAlgorithms[alg] = argument;\n    }\n\n    /**\n     * normalize\n     *\n     * @description\n     * Map JWA alg name to Web Crypto API algorithm parameter\n     *\n     * @param {string} op\n     * @param {Object} alg\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(op, alg) {\n      var registeredAlgorithms = this[op];\n\n      if (!registeredAlgorithms) {\n        return new SyntaxError(); // what kind of error should this be?\n      }\n\n      var argument = registeredAlgorithms[alg];\n\n      if (!argument) {\n        return new NotSupportedError(alg);\n      }\n\n      return argument;\n    }\n  }], [{\n    key: 'operations',\n    get: function get() {\n      return operations;\n    }\n  }]);\n\n  return SupportedAlgorithms;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = SupportedAlgorithms;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Local dependencies\n */\n\nvar HMAC = __webpack_require__(25);\nvar ECDSA = __webpack_require__(24);\nvar RSASSA_PKCS1_v1_5 = __webpack_require__(26);\nvar SupportedAlgorithms = __webpack_require__(27);\n\n/**\n * Register Supported Algorithms\n */\nvar supportedAlgorithms = new SupportedAlgorithms();\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('KS256', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'K-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES256', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES384', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('ES512', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\nsupportedAlgorithms.define('none', 'sign', {});\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('KS256', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'K-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES256', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES384', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('ES512', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\nsupportedAlgorithms.define('none', 'verify', {});\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('KS256', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'K-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES256', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES384', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('ES512', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  DataError: __webpack_require__(4),\n  NotSupportedError: __webpack_require__(10)\n};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Package dependencies\n */\n\nvar _require = __webpack_require__(0),\n    Formats = _require.Formats;\n\n/**\n * Format extensions\n */\n\nFormats.register('StringOrURI', new RegExp());\nFormats.register('NumericDate', new RegExp());\nFormats.register('URI', new RegExp());\nFormats.register('url', new RegExp());\nFormats.register('base64', new RegExp());\nFormats.register('base64url', new RegExp());\nFormats.register('MediaType', new RegExp());\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(0),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSetSchema = __webpack_require__(15);\nvar JWK = __webpack_require__(12);\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\n\nvar JWKSet = function (_JSONDocument) {\n  _inherits(JWKSet, _JSONDocument);\n\n  function JWKSet() {\n    _classCallCheck(this, JWKSet);\n\n    return _possibleConstructorReturn(this, (JWKSet.__proto__ || Object.getPrototypeOf(JWKSet)).apply(this, arguments));\n  }\n\n  _createClass(JWKSet, null, [{\n    key: 'importKeys',\n\n    /**\n     * importKeys\n     */\n    value: function importKeys(jwks) {\n      var validation = this.schema.validate(jwks);\n\n      if (!validation.valid) {\n        return Promise.reject(new Error('Invalid JWKSet: ' + JSON.stringify(validation, null, 2)));\n      }\n\n      if (!jwks.keys) {\n        return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'));\n      }\n\n      var imported = void 0,\n          importing = void 0;\n\n      try {\n        imported = new JWKSet(jwks);\n        importing = jwks.keys.map(function (key) {\n          return JWK.importKey(key);\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n\n      return Promise.all(importing).then(function (keys) {\n        imported.keys = keys;\n        return imported;\n      });\n    }\n  }, {\n    key: 'schema',\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWKSetSchema;\n    }\n  }]);\n\n  return JWKSet;\n}(JSONDocument);\n\n/**\n * Export\n */\n\nmodule.exports = JWKSet;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JSONPatch = __webpack_require__(20);\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = JSONDocument;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JSONPointer = __webpack_require__(8);\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\nmodule.exports = JSONMapping;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n  } else {\n    obj[key] = value;\n  }return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Initializer = __webpack_require__(19);\nvar Validator = __webpack_require__(21);\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\nmodule.exports = JSONSchema;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction placeHoldersCount(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n}\n\nfunction byteLength(b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64);\n}\n\nfunction toByteArray(b64) {\n  var i, l, tmp, placeHolders, arr;\n  var len = b64.length;\n  placeHolders = placeHoldersCount(b64);\n\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0; i < l; i += 4) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = tmp >> 16 & 0xFF;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[tmp << 4 & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    output += lookup[tmp >> 10];\n    output += lookup[tmp >> 4 & 0x3F];\n    output += lookup[tmp << 2 & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('');\n}\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nvar pad_string_1 = __webpack_require__(37);\nfunction encode(input, encoding) {\n    if (encoding === void 0) {\n        encoding = \"utf8\";\n    }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(new Buffer(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) {\n        encoding = \"utf8\";\n    }\n    return new Buffer(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url).replace(/\\-/g, \"+\").replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return new Buffer(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = base64url;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = new Buffer(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = padString;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\nmodule.exports = TextEncoder;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(23);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// jose.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 41);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 64de05bc59c3f0f16cce","'use strict';\n\nmodule.exports = {\n  Formats: require('./Formats'),\n  Initializer: require('./Initializer'),\n  JSONDocument: require('./JSONDocument'),\n  JSONMapping: require('./JSONMapping'),\n  JSONPatch: require('./JSONPatch'),\n  JSONPointer: require('./JSONPointer'),\n  JSONSchema: require('./JSONSchema'),\n  Validator: require('./Validator')\n};\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/index.js","module.exports = require('./dist/base64url').default;\nmodule.exports.default = module.exports;\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64url/index.js","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/buffer/index.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\nvar _require2 = require('../formats'),\n    BASE64_REGEXP = _require2.BASE64_REGEXP;\n\n/**\n * JWK Schema\n */\n\n\nvar JWKSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    kty: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['RSA', 'EC', 'oct'] // other values MAY be used\n    },\n\n    use: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['sig', 'enc'] // other values MAY be used\n    },\n\n    key_ops: {\n      type: 'array',\n      //format: 'case-sensitive',\n      items: {\n        enum: ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'] // other values MAY be used\n      }\n    },\n\n    alg: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512', 'none'] // other values MAY be used\n    },\n\n    kid: {\n      type: 'string'\n    },\n\n    x5u: {\n      type: 'string'\n      //format: 'url'\n    },\n\n    x5c: {\n      type: 'array'\n      //format: BASE64_REGEXP\n    },\n\n    x5t: {\n      type: 'string'\n      //format: BASE64_REGEXP\n    }\n\n    //'x5t#S256': {\n    //  type: 'string',\n    //  //format: BASE64_REGEXP\n    //}\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWKSchema.js","\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * DataError\n */\nvar DataError = function (_Error) {\n  _inherits(DataError, _Error);\n\n  function DataError(message) {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message));\n  }\n\n  return DataError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = DataError;\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/DataError.js","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\nvar base64url = require('base64url');\nvar supportedAlgorithms = require('../algorithms');\n\nvar _require = require('../errors'),\n    NotSupportedError = _require.NotSupportedError;\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\n\n\nvar JWA = function () {\n  function JWA() {\n    _classCallCheck(this, JWA);\n  }\n\n  _createClass(JWA, null, [{\n    key: 'sign',\n\n\n    /**\n     * Sign\n     *\n     * @description\n     * Create a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} key\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n    value: function sign(alg, key, data) {\n      // normalize the algorithm\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg);\n\n      // validate algorithm is supported\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // validate type of key\n      // TODO\n      //  - is the key suitable for the algorithm?\n      //  - does that get validated in webcrypto?\n      //if (key instanceof CryptoKey) {\n      //  return Promise.reject(new InvalidKeyError())\n      //}\n\n      // sign the data\n      return normalizedAlgorithm.sign(key, data);\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} privateKey\n     * @param {string|Buffer} signature\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(alg, key, signature, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // TODO\n      // validate publicKey\n\n      // verify the signature\n      return normalizedAlgorithm.verify(key, signature, data);\n    }\n\n    /**\n     * Encrypt\n     */\n\n    /**\n     * Decrypt\n     */\n\n    /**\n     * Import\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg);\n      return normalizedAlgorithm.importKey(key);\n    }\n  }]);\n\n  return JWA;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWA;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWA.js","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Dependencies\n */\nvar base64url = require('base64url');\n\nvar _require = require('@trust/json-document'),\n    JSONDocument = _require.JSONDocument;\n\nvar JWTSchema = require('../schemas/JWTSchema');\nvar JWA = require('./JWA');\nvar DataError = require('../errors/DataError');\n\n/**\n * Helper Functions\n * @ignore\n */\nfunction clean(input) {\n  return JSON.parse(JSON.stringify(input));\n}\n\n/**\n * JWT\n */\n\nvar JWT = function (_JSONDocument) {\n  _inherits(JWT, _JSONDocument);\n\n  /**\n   * constructor\n   */\n  function JWT(data) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JWT);\n\n    options.filter = options.filter || false;\n\n    var _this = _possibleConstructorReturn(this, (JWT.__proto__ || Object.getPrototypeOf(JWT)).call(this, data, options));\n\n    var type = data.type,\n        serialization = data.serialization;\n\n\n    Object.defineProperty(_this, 'type', { value: type, configurable: true, enumerable: false });\n    Object.defineProperty(_this, 'serialization', { value: serialization, configurable: true, enumerable: false });\n    return _this;\n  }\n\n  /**\n   * schema\n   */\n\n\n  _createClass(JWT, [{\n    key: 'isJWE',\n\n\n    /**\n     * isJWE\n     *\n     * @todo\n     */\n    value: function isJWE() {\n      return false;\n    }\n\n    /**\n     * resolveKeys\n     *\n     * @todo  This needs to be updated for use with the new API\n     */\n    // resolveKeys (jwks) {\n    //   let kid = this.header.kid\n\n    //   let keys, match\n\n    //   // treat an array as the \"keys\" property of a JWK Set\n    //   if (Array.isArray(jwks)) {\n    //     keys = jwks\n    //   }\n\n    //   // presence of keys indicates object is a JWK Set\n    //   if (jwks.keys) {\n    //     keys = jwks.keys\n    //   }\n\n    //   // wrap a plain object they is not a JWK Set in Array\n    //   if (!jwks.keys && typeof jwks === 'object') {\n    //     keys = [jwks]\n    //   }\n\n    //   // ensure there are keys to search\n    //   if (!keys) {\n    //     throw new DataError('Invalid JWK argument')\n    //   }\n\n    //   // match by \"kid\" or \"use\" header\n    //   if (kid) {\n    //     match = keys.find(jwk => jwk.kid === kid)\n    //   } else {\n    //     match = keys.find(jwk => jwk.use === 'sig')\n    //   }\n\n    //   // assign matching key to JWT and return a boolean\n    //   if (match) {\n    //     console.log(match)\n    //     this.key = match.cryptoKey\n    //     return true\n    //   } else {\n    //     return false\n    //   }\n    // }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token instance\n     *\n     * @param {...Object} data\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {\n        data[_key] = arguments[_key];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return this.sign(params);\n      }\n    }\n\n    /**\n     * sign\n     *\n     * @description\n     * Sign a JWT instance\n     *\n     * @todo import different types of key\n     *\n     * @param {...Object} data\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'sign',\n    value: function sign() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, data = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        data[_key2] = arguments[_key2];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      var payload = this.payload;\n      var protectedHeader = params.protected,\n          unprotectedHeader = params.header,\n          signature = params.signature,\n          signatures = params.signatures,\n          serialization = params.serialization,\n          cryptoKey = params.cryptoKey,\n          _params$validate = params.validate,\n          validate = _params$validate === undefined ? true : _params$validate,\n          result = params.result;\n\n\n      if (validate) {\n        var validation = this.validate();\n\n        if (!validation.valid) {\n          return Promise.reject(validation);\n        }\n      }\n\n      // Override serialization\n      if (serialization) {\n        Object.defineProperty(this, 'serialization', {\n          value: serialization,\n          enumerable: false,\n          configurable: true\n        });\n      }\n\n      // Normalize new flat signature\n      if (cryptoKey && !signature && (unprotectedHeader || protectedHeader)) {\n        var descriptor = {};\n\n        if (!protectedHeader && unprotectedHeader) {\n          descriptor.protected = unprotectedHeader;\n        } else {\n          descriptor.protected = protectedHeader;\n          descriptor.header = unprotectedHeader;\n        }\n\n        descriptor.cryptoKey = cryptoKey;\n\n        // Add to signatures array\n        if (signatures && Array.isArray(signatures)) {\n          signatures.push(descriptor);\n        } else {\n          signatures = [descriptor];\n        }\n      }\n\n      // Create signatures\n      var promises = [];\n      if (signatures && Array.isArray(signatures)) {\n        // Ignore ambiguous/invalid descriptors\n        promises = signatures.filter(function (descriptor) {\n          return descriptor.cryptoKey && !descriptor.signature;\n\n          // assemble and sign\n        }).map(function (descriptor) {\n          var protectedHeader = descriptor.protected,\n              unprotectedHeader = descriptor.header,\n              signature = descriptor.signature,\n              cryptoKey = descriptor.cryptoKey;\n          var alg = protectedHeader.alg;\n\n          // Encode signature content\n\n          var encodedHeader = base64url(JSON.stringify(protectedHeader));\n          var encodedPayload = base64url(JSON.stringify(payload));\n          var data = encodedHeader + '.' + encodedPayload;\n\n          return JWA.sign(alg, cryptoKey, data).then(function (signature) {\n            return { protected: protectedHeader, header: unprotectedHeader, signature: signature };\n          });\n        });\n      }\n\n      // Await signatures\n      return Promise.all(promises).then(function (signatures) {\n        if (signatures.length > 0) {\n          if (_this2.signatures && Array.isArray(_this2.signatures)) {\n            _this2.signatures = _this2.signatures.concat(signatures);\n          } else {\n            _this2.signatures = signatures;\n          }\n        }\n\n        if (!result || result === 'string') {\n          return _this2.serialize();\n        } else if (result === 'object' || result === 'instance') {\n          return _this2;\n        }\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a decoded JSON Web Token instance\n     *\n     * @todo jwk, jwkSet and pem key types\n     *\n     * @param {...Object} data\n     * @returns {Promise<Boolean|Object>}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      var _this3 = this;\n\n      for (var _len3 = arguments.length, data = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        data[_key3] = arguments[_key3];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n      var signatures = this.signatures,\n          payload = this.payload,\n          serialization = this.serialization;\n      var validate = params.validate,\n          result = params.result,\n          cryptoKey = params.cryptoKey,\n          cryptoKeys = params.cryptoKeys;\n\n      // Validate instance\n\n      if (validate) {\n        var validation = this.validate();\n\n        if (!validation.valid) {\n          throw new Error(validation);\n        }\n      }\n\n      // Encode payload\n      var encodedPayload = base64url(JSON.stringify(payload));\n\n      // Verify all signatures with a key present\n      var promises = signatures.map(function (descriptor, index) {\n\n        var key = void 0;\n        // Get manually mapped key\n        if (descriptor.cryptoKey) {\n          key = descriptor.cryptoKey;\n\n          // Get corresponding key\n        } else if (cryptoKeys && Array.isArray(cryptoKeys) && index < cryptoKeys.length && cryptoKeys[index]) {\n\n          key = cryptoKeys[index];\n\n          // Attempt to use the single key\n        } else if (cryptoKey) {\n          key = cryptoKey;\n\n          // No key to verify signature; ignore\n        } else {\n          return Promise.resolve(true);\n        }\n\n        var protectedHeader = descriptor.protected,\n            unprotectedHeader = descriptor.header,\n            signature = descriptor.signature;\n\n        // no signature to verify\n\n        if (!signature) {\n          return Promise.reject(new DataError('Missing signature(s)'));\n        }\n\n        var alg = protectedHeader.alg;\n\n        // Encode header and assemble signature verification data\n\n        var encodedHeader = base64url(JSON.stringify(protectedHeader));\n        var data = encodedHeader + '.' + encodedPayload;\n\n        // Verify signature and store result on the descriptor\n        return JWA.verify(alg, key, signature, data).then(function (verified) {\n          Object.defineProperty(signatures[index], 'verified', {\n            value: verified,\n            enumerable: false,\n            configurable: true\n          });\n          return verified;\n        });\n      });\n\n      // Await verification results\n      return Promise.all(promises).then(function (verified) {\n        verified = verified.reduce(function (prev, val) {\n          return prev ? val : false;\n        }, true);\n\n        Object.defineProperty(_this3, 'verified', {\n          value: verified,\n          enumerable: false,\n          configurable: true\n        });\n\n        if (!result || result === 'boolean') {\n          return verified;\n        } else if (result === 'object' || result === 'instance') {\n          return _this3;\n        }\n      });\n    }\n\n    /**\n     * toCompact\n     */\n\n  }, {\n    key: 'toCompact',\n    value: function toCompact() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      var protectedHeader = void 0,\n          signature = void 0;\n\n      // Signatures present\n      if (signatures && Array.isArray(signatures) && signatures.length > 0) {\n        protectedHeader = signatures[0].protected;\n        signature = signatures[0].signature;\n      }\n\n      if (!protectedHeader) {\n        throw new DataError('Protected header is required');\n      }\n\n      // Encode protected header and payload\n      var encodedPayload = base64url(JSON.stringify(payload));\n      var encodedHeader = base64url(JSON.stringify(protectedHeader));\n      var data = encodedHeader + '.' + encodedPayload;\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        // Return compact JWT with signature\n        if (signature) {\n          return data + '.' + signature;\n\n          // Return compact JWT without signature\n        } else {\n          return data + '.';\n        }\n      }\n    }\n\n    /**\n     * toFlattened\n     */\n\n  }, {\n    key: 'toFlattened',\n    value: function toFlattened() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      var protectedHeader = void 0,\n          unprotectedHeader = void 0,\n          signature = void 0;\n\n      // Signatures present\n      if (signatures && Array.isArray(signatures) && signatures.length > 0) {\n        protectedHeader = signatures[0].protected;\n        unprotectedHeader = signatures[0].header;\n        signature = signatures[0].signature;\n      }\n\n      if (!protectedHeader) {\n        throw new DataError('Protected header is required');\n      }\n\n      // Encode protected header and payload\n      var encodedPayload = base64url(JSON.stringify(payload));\n      var encodedHeader = base64url(JSON.stringify(protectedHeader));\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return JSON.stringify({\n          payload: encodedPayload,\n          header: unprotectedHeader,\n          protected: encodedHeader,\n          signature: signature\n        });\n      }\n    }\n\n    /**\n     * toGeneral\n     */\n\n  }, {\n    key: 'toGeneral',\n    value: function toGeneral() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      // Encode payload\n\n      var encodedPayload = base64url(JSON.stringify(payload));\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        // Return with signature\n        if (signatures) {\n\n          // Serialize signatures\n          var serializedSignatures = signatures.map(function (descriptor) {\n            var unprotectedHeader = descriptor.header,\n                protectedHeader = descriptor.protected,\n                signature = descriptor.signature;\n\n            // Encode protected header\n\n            var encodedHeader = base64url(JSON.stringify(protectedHeader));\n\n            return { header: unprotectedHeader, protected: encodedHeader, signature: signature };\n          });\n\n          return JSON.stringify({\n            payload: encodedPayload,\n            signatures: serializedSignatures\n          });\n\n          // Return without signatures\n        } else {\n          return JSON.stringify({ payload: encodedPayload });\n        }\n      }\n    }\n\n    /**\n     * toJWD\n     *\n     * @description\n     * Convert a JWT to a JWD\n     *\n     * @return {JWD}\n     */\n\n  }, {\n    key: 'toJWD',\n    value: function toJWD() {\n      var JWD = require('./JWD');\n      return new JWD(this);\n    }\n\n    /**\n     * serialize\n     *\n     * @description\n     * Serialize a JWT instance to the preferred serialization\n     *\n     * @return {SerializedToken}\n     */\n\n  }, {\n    key: 'serialize',\n    value: function serialize() {\n      var serialization = this.serialization;\n\n\n      switch (serialization) {\n        case 'compact':\n          return this.toCompact();\n        case 'flattened':\n          return this.toFlattened();\n        case 'json':\n          return this.toGeneral();\n        case 'document':\n          return this.toJWD().toDocumentGeneral();\n        case 'flattened-document':\n          return this.toJWD().toDocumentFlattened();\n        default:\n          return this.toGeneral();\n      }\n    }\n  }], [{\n    key: 'decode',\n\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Token\n     *\n     * @param {String} token\n     * @returns {JWT}\n     */\n    value: function decode(token) {\n      if (typeof token !== 'string') {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Parse\n      if (token.startsWith('{')) {\n        try {\n          token = JSON.parse(token);\n        } catch (err) {\n          throw new DataError('Malformed JWT');\n        }\n      }\n\n      // Compact\n      if (typeof token === 'string') {\n        return this.fromCompact(token);\n      }\n\n      // JSON General\n      if (token.signatures) {\n        return this.fromGeneral(token);\n\n        // JSON Flattened\n      } else {\n        return this.fromFlattened(token);\n      }\n    }\n\n    /**\n     * fromCompact\n     *\n     * @description\n     * Deserialize a Compact JWT and instantiate an instance\n     *\n     * @param  {String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromCompact',\n    value: function fromCompact(data) {\n      var ExtendedJWT = this;\n      var protectedHeader = void 0,\n          payload = void 0,\n          signature = void 0;\n\n      // Parse\n      if (typeof data === 'string') {\n        var segments = data.split('.');\n\n        if (![3, 5].includes(segments.length)) {\n          throw new DataError('Malformed JWT');\n        }\n\n        // Decode base64url\n        if (segments.length === 3) {\n          try {\n            protectedHeader = JSON.parse(base64url.decode(segments[0]));\n            payload = JSON.parse(base64url.decode(segments[1]));\n            signature = segments[2];\n          } catch (err) {\n            throw new DataError('Malformed JWS');\n          }\n        }\n\n        if (segments.length === 5) {\n          // TODO JWE\n        }\n      }\n\n      // Sanity Check\n      if ((typeof protectedHeader === 'undefined' ? 'undefined' : _typeof(protectedHeader)) !== 'object' || protectedHeader === null || Array.isArray(protectedHeader)) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      // Normalize and return instance\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: [{ protected: protectedHeader, signature: signature }],\n        serialization: 'compact',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * fromFlattened\n     *\n     * @description\n     * Deserialize a JSON Flattened JWT and instantiate an instance\n     *\n     * @param  {Object|String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromFlattened',\n    value: function fromFlattened(data) {\n      var ExtendedJWT = this;\n      var protectedHeader = void 0,\n          payload = void 0;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWT');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Decode base64url\n      try {\n        payload = JSON.parse(base64url.decode(data.payload));\n        protectedHeader = JSON.parse(base64url.decode(data.protected));\n      } catch (err) {\n        throw new Error('Invalid JWT');\n      }\n\n      // Fetch decoded values\n      var _data = data,\n          unprotectedHeader = _data.header,\n          signature = _data.signature;\n\n      // Sanity Check\n\n      if ((typeof protectedHeader === 'undefined' ? 'undefined' : _typeof(protectedHeader)) !== 'object' || protectedHeader === null || Array.isArray(protectedHeader)) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      if (unprotectedHeader && ((typeof unprotectedHeader === 'undefined' ? 'undefined' : _typeof(unprotectedHeader)) !== 'object' || unprotectedHeader === null || Array.isArray(unprotectedHeader))) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      // Normalize and return instance\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: [{ protected: protectedHeader, header: unprotectedHeader, signature: signature }],\n        serialization: 'flattened',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * fromGeneral\n     *\n     * @description\n     * Deserialize a JSON General JWT and instantiate an instance\n     *\n     * @param  {Object|String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromGeneral',\n    value: function fromGeneral(data) {\n      var ExtendedJWT = this;\n      var payload = void 0,\n          signatures = void 0;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWT');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Signatures must be present and an array\n      if (!Array.isArray(data.signatures)) {\n        throw new DataError('JWT signatures property must be an array');\n      }\n\n      // Decode payload\n      try {\n        payload = JSON.parse(base64url.decode(data.payload));\n      } catch (err) {\n        throw new Error('Invalid JWT');\n      }\n\n      // Decode signatures\n      signatures = data.signatures.map(function (descriptor) {\n        var protectedHeader = descriptor.protected,\n            unprotectedHeader = descriptor.header,\n            signature = descriptor.signature;\n\n        var decodedHeader = void 0;\n\n        try {\n          decodedHeader = JSON.parse(base64url.decode(protectedHeader));\n        } catch (err) {\n          throw new DataError('Invalid JWT');\n        }\n\n        if (!decodedHeader || (typeof decodedHeader === 'undefined' ? 'undefined' : _typeof(decodedHeader)) !== 'object' || decodedHeader === null || Array.isArray(decodedHeader)) {\n          throw new DataError('JWT Protected Header must be an object');\n        }\n\n        if (unprotectedHeader && ((typeof unprotectedHeader === 'undefined' ? 'undefined' : _typeof(unprotectedHeader)) !== 'object' || unprotectedHeader === null || Array.isArray(unprotectedHeader))) {\n          throw new DataError('JWT Header must be an object');\n        }\n\n        return {\n          protected: decodedHeader,\n          header: unprotectedHeader,\n          signature: signature\n        };\n      });\n\n      // Normalize and return instance\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: signatures,\n        serialization: 'json',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * from\n     *\n     * @description\n     * Instanciate a JWT from an object descriptor\n     *\n     * @param {Object|String} data\n     * @param {String} [data.serialized] - Existing serialized JWT\n     *\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'from',\n    value: function from(data) {\n      var ExtendedJWT = this;\n\n      // Decode serialized token\n      if (typeof data === 'string' || data.serialized) {\n        return this.decode(data.serialized || data);\n      }\n\n      var payload = data.payload,\n          signatures = data.signatures,\n          serialization = data.serialization,\n          filter = data.filter;\n\n\n      if (!payload) {\n        throw new DataError('Invalid JWT');\n      }\n\n      // Include compelete signature descriptors only\n      if (signatures && Array.isArray(signatures)) {\n        signatures = signatures.filter(function (descriptor) {\n          return !descriptor.cryptoKey || descriptor.signature;\n        });\n      } else {\n        signatures = [];\n      }\n\n      // Normalize existing flat signature\n      if (!data.cryptoKey && data.signature) {\n        var protectedHeader = data.protected,\n            unprotectedHeader = data.header,\n            signature = data.signature;\n\n        var descriptor = {};\n\n        if (!protectedHeader && unprotectedHeader) {\n          descriptor.protected = unprotectedHeader;\n        } else {\n          descriptor.protected = protectedHeader;\n          descriptor.header = unprotectedHeader;\n        }\n\n        descriptor.signature = signature;\n\n        if (signatures && Array.isArray(signatures)) {\n          signatures.unshift(descriptor);\n        } else {\n          signatures = [descriptor];\n        }\n      }\n\n      return new ExtendedJWT(clean({\n        payload: payload,\n        signatures: signatures,\n        serialization: serialization,\n        type: 'JWS'\n      }), { filter: filter || ExtendedJWT.name !== 'JWT' && ExtendedJWT.name !== 'JWD' });\n    }\n\n    /**\n     * sign\n     *\n     * @description\n     * Sign a JSON Web Token\n     *\n     * @params {...Object} data - Token data\n     *\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'sign',\n    value: function sign() {\n      for (var _len4 = arguments.length, data = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        data[_key4] = arguments[_key4];\n      }\n\n      // Shallow merge data\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      // Try decode\n      var instance = void 0;\n      try {\n        instance = this.from(params);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      return instance.sign(params);\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token\n     *\n     * @param {...Object} data\n     *\n     * @returns {Promise<SerializedToken>}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      for (var _len5 = arguments.length, data = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        data[_key5] = arguments[_key5];\n      }\n\n      // Shallow merge data\n      var params = Object.assign.apply(Object, [{}].concat(data));\n\n      // Try decode\n      var instance = void 0;\n      try {\n        instance = this.from(params);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      return instance.encode(params);\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Decode and verify a JSON Web Token\n     *\n     * @param {...Object} data\n     * @returns {Promise<JWT>}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      for (var _len6 = arguments.length, data = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        data[_key6] = arguments[_key6];\n      }\n\n      var params = Object.assign.apply(Object, [{}].concat(data));\n      var serialized = params.serialized;\n\n\n      if (!serialized) {\n        throw new Error('JWT input required');\n      }\n\n      // Try decode\n      var instance = void 0;\n      try {\n        instance = this.from(serialized);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n\n      return instance.verify(params);\n    }\n  }, {\n    key: 'schema',\n    get: function get() {\n      return JWTSchema;\n    }\n  }]);\n\n  return JWT;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWT;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWT.js","'use strict';\n\nvar TextEncoder = global.TextEncoder ? global.TextEncoder // browser\n: require('text-encoding').TextEncoder; // node shim\nmodule.exports = TextEncoder;\n\n\n// WEBPACK FOOTER //\n// ./lib/text-encoder/index.js","'use strict';\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPointer;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONPointer.js","module.exports = crypto;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 9\n// module chunks = 0","\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * NotSupportedError\n */\nvar NotSupportedError = function (_Error) {\n  _inherits(NotSupportedError, _Error);\n\n  function NotSupportedError(alg) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this.message = alg + \" is not a supported algorithm\";\n    return _this;\n  }\n\n  return NotSupportedError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = NotSupportedError;\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/NotSupportedError.js","'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Dependencies\n * @ignore\n */\nvar base64url = require('base64url');\nvar JWT = require('./JWT');\nvar DataError = require('../errors/DataError');\n\n/**\n * Helper Functions\n * @ignore\n */\nfunction clean(input) {\n  return JSON.parse(JSON.stringify(input));\n}\n\n/**\n * JWD\n */\n\nvar JWD = function (_JWT) {\n  _inherits(JWD, _JWT);\n\n  function JWD() {\n    _classCallCheck(this, JWD);\n\n    return _possibleConstructorReturn(this, (JWD.__proto__ || Object.getPrototypeOf(JWD)).apply(this, arguments));\n  }\n\n  _createClass(JWD, [{\n    key: 'toDocumentFlattened',\n\n\n    /**\n     * toDocumentFlattened\n     */\n    value: function toDocumentFlattened() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n      var protectedHeader = void 0,\n          unprotectedHeader = void 0,\n          signature = void 0;\n\n      // Signatures present\n      if (signatures && Array.isArray(signatures) && signatures.length > 0) {\n        protectedHeader = signatures[0].protected;\n        unprotectedHeader = signatures[0].header;\n        signature = signatures[0].signature;\n      }\n\n      if (!protectedHeader) {\n        throw new DataError('Protected header is required');\n      }\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return JSON.stringify({\n          payload: payload,\n          header: unprotectedHeader,\n          protected: protectedHeader,\n          signature: signature\n        });\n      }\n    }\n\n    /**\n     * toDocumentGeneral\n     */\n\n  }, {\n    key: 'toDocumentGeneral',\n    value: function toDocumentGeneral() {\n      var payload = this.payload,\n          signatures = this.signatures;\n\n\n      if (this.isJWE()) {\n        // TODO\n      } else {\n        return JSON.stringify({ payload: payload, signatures: signatures });\n      }\n    }\n\n    /**\n     * toJWT\n     *\n     * @description\n     * Convert a JWD to a JWT\n     *\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'toJWT',\n    value: function toJWT() {\n      var JWT = require('./JWT');\n      return new JWT(this);\n    }\n\n    /**\n     * serialize\n     *\n     * @description\n     * Serialize a JWD instance to the preferred serialization\n     *\n     * @return {SerializedToken}\n     */\n\n  }, {\n    key: 'serialize',\n    value: function serialize() {\n      var serialization = this.serialization;\n\n\n      switch (serialization) {\n        case 'compact':\n          return this.toJWT().toCompact();\n        case 'flattened':\n          return this.toJWT().toFlattened();\n        case 'json':\n          return this.toJWT().toGeneral();\n        case 'document':\n          return this.toDocumentGeneral();\n        case 'flattened-document':\n          return this.toDocumentFlattened();\n        default:\n          return this.toDocumentGeneral();\n      }\n    }\n  }], [{\n    key: 'decode',\n\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Document\n     *\n     * @param {String} token\n     *\n     * @returns {JWT}\n     */\n    value: function decode(token) {\n      if (typeof token !== 'string') {\n        throw new DataError('Invalid JWD');\n      }\n\n      if (!token.startsWith('{')) {\n        throw new DataError('Malformed JWD');\n      }\n\n      // Parse\n      try {\n        token = JSON.parse(token);\n      } catch (err) {\n        throw new DataError('Malformed JWD');\n      }\n\n      // Document General\n      if (token.signatures) {\n        return this.fromDocumentGeneral(token);\n\n        // Document Flattened\n      } else {\n        return this.fromDocumentFlattened(token);\n      }\n    }\n\n    /**\n     * fromDocumentFlattened\n     *\n     * @description\n     * Deserialize a Compact JWT and instantiate an instance\n     *\n     * @param  {String} data\n     * @return {JWT}\n     */\n\n  }, {\n    key: 'fromDocumentFlattened',\n    value: function fromDocumentFlattened(data) {\n      var ExtendedJWD = this;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWD');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWD');\n      }\n\n      var _data = data,\n          protectedHeader = _data.protected,\n          unprotectedHeader = _data.header,\n          payload = _data.payload,\n          signature = _data.signature;\n\n      // Sanity Check\n\n      if ((typeof protectedHeader === 'undefined' ? 'undefined' : _typeof(protectedHeader)) !== 'object' || protectedHeader === null || Array.isArray(protectedHeader)) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      if (unprotectedHeader && ((typeof unprotectedHeader === 'undefined' ? 'undefined' : _typeof(unprotectedHeader)) !== 'object' || unprotectedHeader === null || Array.isArray(unprotectedHeader))) {\n        throw new DataError('JWT Header must be an object');\n      }\n\n      // Normalize and return instance\n      return new ExtendedJWD(clean({\n        payload: payload,\n        signatures: [{ protected: protectedHeader, header: unprotectedHeader, signature: signature }],\n        serialization: 'document-flattened',\n        type: 'JWS'\n      }));\n    }\n\n    /**\n     * fromDocumentGeneral\n     *\n     * @description\n     * Deserialize a General JWD and instantiate an instance\n     *\n     * @param  {String} data\n     * @return {JWD}\n     */\n\n  }, {\n    key: 'fromDocumentGeneral',\n    value: function fromDocumentGeneral(data) {\n      var ExtendedJWD = this;\n\n      // Parse\n      if (typeof data === 'string') {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          throw new DataError('Malformed JWD');\n        }\n      }\n\n      // Input should be an object by now\n      if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' || data === null || Array.isArray(data)) {\n        throw new DataError('Invalid JWD');\n      }\n\n      // Signatures must be present and an array\n      if (!Array.isArray(data.signatures)) {\n        throw new DataError('JWD signatures property must be an array');\n      }\n\n      var _data2 = data,\n          payload = _data2.payload,\n          signatures = _data2.signatures;\n\n      // Normalize and return instance\n\n      return new ExtendedJWD(clean({\n        payload: payload,\n        signatures: signatures,\n        serialization: 'document',\n        type: 'JWS'\n      }));\n    }\n  }]);\n\n  return JWD;\n}(JWT);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWD;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWD.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = require('@trust/json-document'),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSchema = require('../schemas/JWKSchema');\nvar JWA = require('./JWA');\n\n/**\n * JWK Class\n */\n\nvar JWK = function (_JSONDocument) {\n  _inherits(JWK, _JSONDocument);\n\n  function JWK() {\n    _classCallCheck(this, JWK);\n\n    return _possibleConstructorReturn(this, (JWK.__proto__ || Object.getPrototypeOf(JWK)).apply(this, arguments));\n  }\n\n  _createClass(JWK, null, [{\n    key: 'importKey',\n\n\n    /**\n     * importKey\n     *\n     * TODO:\n     * - should this be on JWA?\n     */\n    value: function importKey(jwk) {\n      return JWA.importKey(jwk);\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return JWKSchema;\n    }\n  }]);\n\n  return JWK;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWK;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWK.js","'use strict';\n\n/**\n * Dependencies\n */\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * Base64URLSchema\n */\n\n\nvar Base64URLSchema = new JSONSchema({\n  type: 'string',\n  format: 'base64url'\n});\n\n/**\n * Export\n */\nmodule.exports = Base64URLSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/Base64URLSchema.js","'use strict';\n\n/**\n * Dependencies\n */\nvar JWKSchema = require('./JWKSchema');\n\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JOSEHeaderSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-5\n *\n * 5.  JOSE Header\n *\n *   For a JWT object, the members of the JSON object represented by the\n *   JOSE Header describe the cryptographic operations applied to the JWT\n *   and optionally, additional properties of the JWT.  Depending upon\n *   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE\n *   Header values apply.\n */\n\n\nvar JOSEHeaderSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * typ\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.1\n     *\n     * 5.1.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter defined by [JWS] and [JWE] is used\n     *   by JWT applications to declare the media type [IANA.MediaTypes] of\n     *   this complete JWT.  This is intended for use by the JWT application\n     *   when values that are not JWTs could also be present in an application\n     *   data structure that can contain a JWT object; the application can use\n     *   this value to disambiguate among the different kinds of objects that\n     *   might be present.  It will typically not be used by applications when\n     *   it is already known that the object is a JWT.  This parameter is\n     *   ignored by JWT implementations; any processing of this parameter is\n     *   performed by the JWT application.  If present, it is RECOMMENDED that\n     *   its value be \"JWT\" to indicate that this object is a JWT.  While\n     *   media type names are not case sensitive, it is RECOMMENDED that \"JWT\"\n     *   always be spelled using uppercase characters for compatibility with\n     *   legacy implementations.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.9\n     *\n     * 4.1.9.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter is used by JWS applications to\n     *   declare the media type [IANA.MediaTypes] of this complete JWS.  This\n     *   is intended for use by the application when more than one kind of\n     *   object could be present in an application data structure that can\n     *   contain a JWS; the application can use this value to disambiguate\n     *   among the different kinds of objects that might be present.  It will\n     *   typically not be used by applications when the kind of object is\n     *   already known.  This parameter is ignored by JWS implementations; any\n     *   processing of this parameter is performed by the JWS application.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"typ\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"typ\" value not containing a\n     *   '/'.  For instance, a \"typ\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     *   The \"typ\" value \"JOSE\" can be used by applications to indicate that\n     *   this object is a JWS or JWE using the JWS Compact Serialization or\n     *   the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be\n     *   used by applications to indicate that this object is a JWS or JWE\n     *   using the JWS JSON Serialization or the JWE JSON Serialization.\n     *   Other type values can also be used by applications.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.11\n     *\n     * 4.1.11.  \"typ\" (Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"typ\" Header Parameter defined in Section 4.1.9 of [JWS], except\n     *   that the type is that of this complete JWE.\n     */\n    typ: {\n      type: 'string'\n    },\n\n    /**\n     * cty\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.2\n     *\n     * 5.2.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter defined by [JWS] and [JWE]\n     *   is used by this specification to convey structural information about\n     *   the JWT.\n     *\n     *   In the normal case in which nested signing or encryption operations\n     *   are not employed, the use of this Header Parameter is NOT\n     *   RECOMMENDED.  In the case that nested signing or encryption is\n     *   employed, this Header Parameter MUST be present; in this case, the\n     *   value MUST be \"JWT\", to indicate that a Nested JWT is carried in this\n     *   JWT.  While media type names are not case sensitive, it is\n     *   RECOMMENDED that \"JWT\" always be spelled using uppercase characters\n     *   for compatibility with legacy implementations.  See Appendix A.2 for\n     *   an example of a Nested JWT.\n     *\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.10\n     *\n     * 4.1.10.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter is used by JWS applications\n     *   to declare the media type [IANA.MediaTypes] of the secured content\n     *   (the payload).  This is intended for use by the application when more\n     *   than one kind of object could be present in the JWS Payload; the\n     *   application can use this value to disambiguate among the different\n     *   kinds of objects that might be present.  It will typically not be\n     *   used by applications when the kind of object is already known.  This\n     *   parameter is ignored by JWS implementations; any processing of this\n     *   parameter is performed by the JWS application.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"cty\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"cty\" value not containing a\n     *   '/'.  For instance, a \"cty\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.12\n     *\n     * 4.1.12.  \"cty\" (Content Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"cty\" Header Parameter defined in Section 4.1.10 of [JWS], except\n     *   that the type is that of the secured content (the plaintext).\n     */\n    cty: {\n      type: 'string',\n      enum: ['JWT', 'JWD']\n    },\n\n    /**\n     * alg\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   The \"alg\" (algorithm) Header Parameter identifies the cryptographic\n     *   algorithm used to secure the JWS.  The JWS Signature value is not\n     *   valid if the \"alg\" value does not represent a supported algorithm or\n     *   if there is not a key for use with that algorithm associated with the\n     *   party that digitally signed or MACed the content.  \"alg\" values\n     *   should either be registered in the IANA \"JSON Web Signature and\n     *   Encryption Algorithms\" registry established by [JWA] or be a value\n     *   that contains a Collision-Resistant Name.  The \"alg\" value is a case-\n     *   sensitive ASCII string containing a StringOrURI value.  This Header\n     *   Parameter MUST be present and MUST be understood and processed by\n     *   implementations.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 3.1 of [JWA].\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"alg\" Header Parameter defined in Section 4.1.1 of [JWS], except\n     *   that the Header Parameter identifies the cryptographic algorithm used\n     *   to encrypt or determine the value of the CEK.  The encrypted content\n     *   is not usable if the \"alg\" value does not represent a supported\n     *   algorithm, or if the recipient does not have a key that can be used\n     *   with that algorithm.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 4.1 of [JWA].\n     */\n    alg: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * jku\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.2\n     *\n     * 4.1.2.  \"jku\" (JWK Set URL) Header Parameter (JWS)\n     *\n     *   The \"jku\" (JWK Set URL) Header Parameter is a URI [RFC3986] that\n     *   refers to a resource for a set of JSON-encoded public keys, one of\n     *   which corresponds to the key used to digitally sign the JWS.  The\n     *   keys MUST be encoded as a JWK Set [JWK].  The protocol used to\n     *   acquire the resource MUST provide integrity protection; an HTTP GET\n     *   request to retrieve the JWK Set MUST use Transport Layer Security\n     *   (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n     *   validated, as per Section 6 of RFC 6125 [RFC6125].  Also, see\n     *   Section 8 on TLS requirements.  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.4\n     *\n     * 4.1.4.  \"jku\" (JWK Set URL) Header Parameter (JWE)\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jku\" Header Parameter defined in Section 4.1.2 of [JWS], except\n     *   that the JWK Set resource contains the public key to which the JWE\n     *   was encrypted; this can be used to determine the private key needed\n     *   to decrypt the JWE.\n     */\n    jku: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * jwk\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.3\n     *\n     * 4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   The \"jwk\" (JSON Web Key) Header Parameter is the public key that\n     *   corresponds to the key used to digitally sign the JWS.  This key is\n     *   represented as a JSON Web Key [JWK].  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.5\n     *\n     * 4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jwk\" Header Parameter defined in Section 4.1.3 of [JWS], except\n     *   that the key is the public key to which the JWE was encrypted; this\n     *   can be used to determine the private key needed to decrypt the JWE.\n     */\n    //jwk: JWKSchema,\n\n    /**\n     * kid\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.4\n     *\n     * 4.1.4.  \"kid\" (Key ID) Header Parameter\n     *\n     *   The \"kid\" (key ID) Header Parameter is a hint indicating which key\n     *   was used to secure the JWS.  This parameter allows originators to\n     *   explicitly signal a change of key to recipients.  The structure of\n     *   the \"kid\" value is unspecified.  Its value MUST be a case-sensitive\n     *   string.  Use of this Header Parameter is OPTIONAL.\n     *\n     *   When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n     *   parameter value.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.6\n     *\n     * 4.1.6.  \"kid\" (Key ID) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"kid\" Header Parameter defined in Section 4.1.4 of [JWS], except\n     *   that the key hint references the public key to which the JWE was\n     *   encrypted; this can be used to determine the private key needed to\n     *   decrypt the JWE.  This parameter allows originators to explicitly\n     *   signal a change of key to JWE recipients.\n     */\n    kid: {\n      type: 'string'\n    },\n\n    /**\n     * x5u\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.5\n     *\n     * 4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   The \"x5u\" (X.509 URL) Header Parameter is a URI [RFC3986] that refers\n     *   to a resource for the X.509 public key certificate or certificate\n     *   chain [RFC5280] corresponding to the key used to digitally sign the\n     *   JWS.  The identified resource MUST provide a representation of the\n     *   certificate or certificate chain that conforms to RFC 5280 [RFC5280]\n     *   in PEM-encoded form, with each certificate delimited as specified in\n     *   Section 6.1 of RFC 4945 [RFC4945].  The certificate containing the\n     *   public key corresponding to the key used to digitally sign the JWS\n     *   MUST be the first certificate.  This MAY be followed by additional\n     *   certificates, with each subsequent certificate being the one used to\n     *   certify the previous one.  The protocol used to acquire the resource\n     *   MUST provide integrity protection; an HTTP GET request to retrieve\n     *   the certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n     *   the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n     *   Also, see Section 8 on TLS requirements.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.7\n     *\n     * 4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5u\" Header Parameter defined in Section 4.1.5 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5u: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * x5c\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.6\n     *\n     * 4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   The \"x5c\" (X.509 certificate chain) Header Parameter contains the\n     *   X.509 public key certificate or certificate chain [RFC5280]\n     *   corresponding to the key used to digitally sign the JWS.  The\n     *   certificate or certificate chain is represented as a JSON array of\n     *   certificate value strings.  Each string in the array is a\n     *   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER\n     *   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n     *   the public key corresponding to the key used to digitally sign the\n     *   JWS MUST be the first certificate.  This MAY be followed by\n     *   additional certificates, with each subsequent certificate being the\n     *   one used to certify the previous one.  The recipient MUST validate\n     *   the certificate chain according to RFC 5280 [RFC5280] and consider\n     *   the certificate or certificate chain to be invalid if any validation\n     *   failure occurs.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.8\n     *\n     * 4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5c\" Header Parameter defined in Section 4.1.6 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5c: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'base64'\n      }\n    },\n\n    /**\n     * x5t\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.7\n     *\n     * 4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   The \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n     *   base64url-encoded SHA-1 thumbprint (a.k.a. digest) of the DER\n     *   encoding of the X.509 certificate [RFC5280] corresponding to the key\n     *   used to digitally sign the JWS.  Note that certificate thumbprints\n     *   are also sometimes known as certificate fingerprints.  Use of this\n     *   Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.9\n     *\n     * 4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t\" Header Parameter defined in Section 4.1.7 of [JWS], except\n     *   that the certificate referenced by the thumbprint contains the public\n     *   key to which the JWE was encrypted; this can be used to determine the\n     *   private key needed to decrypt the JWE.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     */\n    x5t: {\n      type: 'string',\n      format: 'base64url'\n    },\n\n    /**\n     * x5t#S256\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.8\n     *\n     * 4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *         Parameter\n     *\n     *   The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n     *   Parameter is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n     *   of the DER encoding of the X.509 certificate [RFC5280] corresponding\n     *   to the key used to digitally sign the JWS.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.10\n     *\n     * 4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *          Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n     *   except that the certificate referenced by the thumbprint contains the\n     *   public key to which the JWE was encrypted; this can be used to\n     *   determine the private key needed to decrypt the JWE.  Note that\n     *   certificate thumbprints are also sometimes known as certificate\n     *   fingerprints.\n     */\n    //'x5t#S256': {\n    //  type: 'string',\n    //  format: 'base64url'\n    //},\n\n    /**\n     * crit\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.11\n     *\n     * 4.1.11.  \"crit\" (Critical) Header Parameter\n     *\n     *   The \"crit\" (critical) Header Parameter indicates that extensions to\n     *   this specification and/or [JWA] are being used that MUST be\n     *   understood and processed.  Its value is an array listing the Header\n     *   Parameter names present in the JOSE Header that use those extensions.\n     *   If any of the listed extension Header Parameters are not understood\n     *   and supported by the recipient, then the JWS is invalid.  Producers\n     *   MUST NOT include Header Parameter names defined by this specification\n     *   or [JWA] for use with JWS, duplicate names, or names that do not\n     *   occur as Header Parameter names within the JOSE Header in the \"crit\"\n     *   list.  Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n     *   value.  Recipients MAY consider the JWS to be invalid if the critical\n     *   list contains any Header Parameter names defined by this\n     *   specification or [JWA] for use with JWS or if any other constraints\n     *   on its use are violated.  When used, this Header Parameter MUST be\n     *   integrity protected; therefore, it MUST occur only within the JWS\n     *   Protected Header.  Use of this Header Parameter is OPTIONAL.  This\n     *   Header Parameter MUST be understood and processed by implementations.\n     *\n     *   An example use, along with a hypothetical \"exp\" (expiration time)\n     *   field is:\n     *\n     *     {\"alg\":\"ES256\",\n     *     \"crit\":[\"exp\"],\n     *     \"exp\":1363284000\n     *     }\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.13\n     *\n     *   4.1.13.  \"crit\" (Critical) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"crit\" Header Parameter defined in Section 4.1.11 of [JWS],\n     *   except that Header Parameters for a JWE are being referred to, rather\n     *   than Header Parameters for a JWS.\n     */\n    crit: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      minItems: 1\n    },\n\n    /**\n     * enc\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.2\n     *\n     * 4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n     *\n     *   The \"enc\" (encryption algorithm) Header Parameter identifies the\n     *   content encryption algorithm used to perform authenticated encryption\n     *   on the plaintext to produce the ciphertext and the Authentication\n     *   Tag.  This algorithm MUST be an AEAD algorithm with a specified key\n     *   length.  The encrypted content is not usable if the \"enc\" value does\n     *   not represent a supported algorithm.  \"enc\" values should either be\n     *   registered in the IANA \"JSON Web Signature and Encryption Algorithms\"\n     *   registry established by [JWA] or be a value that contains a\n     *   Collision-Resistant Name.  The \"enc\" value is a case-sensitive ASCII\n     *   string containing a StringOrURI value.  This Header Parameter MUST be\n     *   present and MUST be understood and processed by implementations.\n     *\n     *   A list of defined \"enc\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 5.1 of [JWA].\n     */\n    enc: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * zip\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.3\n     *\n     * 4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n     *\n     *   The \"zip\" (compression algorithm) applied to the plaintext before\n     *   encryption, if any.  The \"zip\" value defined by this specification\n     *   is:\n     *\n     *   o  \"DEF\" - Compression with the DEFLATE [RFC1951] algorithm\n     *\n     *   Other values MAY be used.  Compression algorithm values can be\n     *   registered in the IANA \"JSON Web Encryption Compression Algorithms\"\n     *   registry established by [JWA].  The \"zip\" value is a case-sensitive\n     *   string.  If no \"zip\" parameter is present, no compression is applied\n     *   to the plaintext before encryption.  When used, this Header Parameter\n     *   MUST be integrity protected; therefore, it MUST occur only within the\n     *   JWE Protected Header.  Use of this Header Parameter is OPTIONAL.\n     *   This Header Parameter MUST be understood and processed by\n     *   implementations.\n     */\n    zip: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JOSEHeaderSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JOSEHeaderSchema.js","'use strict';\n\n/**\n * Dependencies\n */\n\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\nvar JWKSchema = require('./JWKSchema');\n\n/**\n * JWKSetSchema\n */\nvar JWKSetSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: JWKSchema\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSetSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWKSetSchema.js","'use strict';\n\n/**\n * Dependencies\n */\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTClaimsSetSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-4\n *\n * 4.  JWT Claims\n *\n *   The JWT Claims Set represents a JSON object whose members are the\n *   claims conveyed by the JWT.  The Claim Names within a JWT Claims Set\n *   MUST be unique; JWT parsers MUST either reject JWTs with duplicate\n *   Claim Names or use a JSON parser that returns only the lexically last\n *   duplicate member name, as specified in Section 15.12 (\"The JSON\n *   Object\") of ECMAScript 5.1 [ECMAScript].\n *\n *   The set of claims that a JWT must contain to be considered valid is\n *   context dependent and is outside the scope of this specification.\n *   Specific applications of JWTs will require implementations to\n *   understand and process some claims in particular ways.  However, in\n *   the absence of such requirements, all claims that are not understood\n *   by implementations MUST be ignored.\n *\n *   There are three classes of JWT Claim Names: Registered Claim Names,\n *   Public Claim Names, and Private Claim Names.\n */\n\n\nvar JWTClaimsSetSchema = new JSONSchema({\n  // additionalProperties: true,\n  properties: {\n\n    /**\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1\n     *\n     * 4.1.  Registered Claim Names\n     *\n     *   The following Claim Names are registered in the IANA \"JSON Web Token\n     *   Claims\" registry established by Section 10.1.  None of the claims\n     *   defined below are intended to be mandatory to use or implement in all\n     *   cases, but rather they provide a starting point for a set of useful,\n     *   interoperable claims.  Applications using JWTs should define which\n     *   specific claims they use and when they are required or optional.  All\n     *   the names are short because a core goal of JWTs is for the\n     *   representation to be compact.\n     */\n\n    /**\n     * iss\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.1\n     *\n     * 4.1.1.  \"iss\" (Issuer) Claim\n     *\n     *   The \"iss\" (issuer) claim identifies the principal that issued the\n     *   JWT.  The processing of this claim is generally application specific.\n     *   The \"iss\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    iss: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * sub\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.2\n     *\n     * 4.1.2.  \"sub\" (Subject) Claim\n     *\n     *   The \"sub\" (subject) claim identifies the principal that is the\n     *   subject of the JWT.  The claims in a JWT are normally statements\n     *   about the subject.  The subject value MUST either be scoped to be\n     *   locally unique in the context of the issuer or be globally unique.\n     *   The processing of this claim is generally application specific.  The\n     *   \"sub\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    sub: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * aud\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.3\n     *\n     * 4.1.3.  \"aud\" (Audience) Claim\n     *\n     *   The \"aud\" (audience) claim identifies the recipients that the JWT is\n     *   intended for.  Each principal intended to process the JWT MUST\n     *   identify itself with a value in the audience claim.  If the principal\n     *   processing the claim does not identify itself with a value in the\n     *   \"aud\" claim when this claim is present, then the JWT MUST be\n     *   rejected.  In the general case, the \"aud\" value is an array of case-\n     *   sensitive strings, each containing a StringOrURI value.  In the\n     *   special case when the JWT has one audience, the \"aud\" value MAY be a\n     *   single case-sensitive string containing a StringOrURI value.  The\n     *   interpretation of audience values is generally application specific.\n     *   Use of this claim is OPTIONAL.\n     */\n    aud: {\n      type: ['array', 'string'],\n      format: 'StringOrURI',\n      items: {\n        format: 'StringOrURI'\n      }\n    },\n\n    /**\n     * exp\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.4\n     *\n     * 4.1.4.  \"exp\" (Expiration Time) Claim\n     *\n     *   The \"exp\" (expiration time) claim identifies the expiration time on\n     *   or after which the JWT MUST NOT be accepted for processing.  The\n     *   processing of the \"exp\" claim requires that the current date/time\n     *   MUST be before the expiration date/time listed in the \"exp\" claim.\n     *\n     *   Implementers MAY provide for some small leeway, usually no more than\n     *   a few minutes, to account for clock skew.  Its value MUST be a number\n     *   containing a NumericDate value.  Use of this claim is OPTIONAL.\n     *\n     */\n    exp: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * nbf\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.5\n     *\n     * 4.1.5.  \"nbf\" (Not Before) Claim\n     *\n     *   The \"nbf\" (not before) claim identifies the time before which the JWT\n     *   MUST NOT be accepted for processing.  The processing of the \"nbf\"\n     *   claim requires that the current date/time MUST be after or equal to\n     *   the not-before date/time listed in the \"nbf\" claim.  Implementers MAY\n     *   provide for some small leeway, usually no more than a few minutes, to\n     *   account for clock skew.  Its value MUST be a number containing a\n     *   NumericDate value.  Use of this claim is OPTIONAL.\n     */\n    nbf: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * iat\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.6\n     *\n     * 4.1.6.  \"iat\" (Issued At) Claim\n     *\n     *   The \"iat\" (issued at) claim identifies the time at which the JWT was\n     *   issued.  This claim can be used to determine the age of the JWT.  Its\n     *   value MUST be a number containing a NumericDate value.  Use of this\n     *   claim is OPTIONAL.\n     */\n    iat: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * jti\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.7\n     *\n     * 4.1.7.  \"jti\" (JWT ID) Claim\n     *\n     *   The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n     *   The identifier value MUST be assigned in a manner that ensures that\n     *   there is a negligible probability that the same value will be\n     *   accidentally assigned to a different data object; if the application\n     *   uses multiple issuers, collisions MUST be prevented among values\n     *   produced by different issuers as well.  The \"jti\" claim can be used\n     *   to prevent the JWT from being replayed.  The \"jti\" value is a case-\n     *   sensitive string.  Use of this claim is OPTIONAL.\n     */\n    jti: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTClaimsSetSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWTClaimsSetSchema.js","'use strict';\n\n/**\n * Dependencies\n */\nvar Base64URLSchema = require('./Base64URLSchema');\nvar JWTClaimsSetSchema = require('./JWTClaimsSetSchema');\nvar JOSEHeaderSchema = require('./JOSEHeaderSchema');\n\nvar _require = require('@trust/json-document'),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTSchema\n *\n * @description\n * This schema represents all the things a deserialized JWT can be, i.e.,\n * either a JWS or JWE, and any serialization of them. Validation of well-\n * formedness for a given serialization is accomplished at the time of\n * encoding.\n */\n\n\nvar JWTSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * iv\n     */\n    iv: Base64URLSchema,\n\n    /**\n     * aad\n     */\n    aad: Base64URLSchema,\n\n    /**\n     * ciphertext\n     */\n    ciphertext: Base64URLSchema,\n\n    /**\n     * tag\n     */\n    tag: Base64URLSchema,\n\n    /**\n     * recipients\n     */\n    recipients: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          header: JOSEHeaderSchema,\n          encrypted_key: Base64URLSchema\n        }\n      }\n    },\n\n    /**\n     * payload\n     */\n    payload: JWTClaimsSetSchema,\n\n    /**\n     * signatures\n     */\n    signatures: {\n      type: 'array'\n      // items: {\n      //   type: 'object',\n      //   properties: {\n      //     protected: JOSEHeaderSchema,\n      //     header: JOSEHeaderSchema,\n      //     signature: Base64URLSchema\n      //   }\n      // }\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTSchema;\n\n\n// WEBPACK FOOTER //\n// ./lib/schemas/JWTSchema.js","'use strict';\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Formats.initialize();\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/Formats.js","'use strict';\n\n/**\n * Initializer\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/Initializer.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = require('./JSONPointer');\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPatch;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONPatch.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar formats = require('./Formats');\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Validator;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/Validator.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","'use strict';\n\n/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nvar JWA = require('./jose/JWA');\nvar JWK = require('./jose/JWK');\nvar JWKSet = require('./jose/JWKSet');\nvar JWT = require('./jose/JWT');\nvar JWD = require('./jose/JWD');\nvar Base64URLSchema = require('./schemas/Base64URLSchema');\nvar JOSEHeaderSchema = require('./schemas/JOSEHeaderSchema');\nvar JWKSchema = require('./schemas/JWKSchema');\nvar JWKSetSchema = require('./schemas/JWKSetSchema');\nvar JWTClaimsSetSchema = require('./schemas/JWTClaimsSetSchema');\nvar JWTSchema = require('./schemas/JWTSchema');\n\n/**\n * Export\n */\nmodule.exports = {\n  JWA: JWA,\n  JWK: JWK,\n  JWKSet: JWKSet,\n  JWT: JWT,\n  JWD: JWD,\n  Base64URLSchema: Base64URLSchema,\n  JOSEHeaderSchema: JOSEHeaderSchema,\n  JWKSchema: JWKSchema,\n  JWKSetSchema: JWKSetSchema,\n  JWTClaimsSetSchema: JWTClaimsSetSchema,\n  JWTSchema: JWTSchema\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/index.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = require('base64url');\nvar crypto = require('@trust/webcrypto');\nvar TextEncoder = require('../text-encoder');\n\n/**\n * ECDSA\n */\n\nvar ECDSA = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function ECDSA(params) {\n    _classCallCheck(this, ECDSA);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(ECDSA, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return ECDSA;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = ECDSA;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/ECDSA.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = require('base64url');\nvar crypto = require('@trust/webcrypto');\nvar TextEncoder = require('../text-encoder');\n\n/**\n * HMAC with SHA-2 Functions\n */\n\nvar HMAC = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  function HMAC(params) {\n    _classCallCheck(this, HMAC);\n\n    this.params = params;\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO: validate key length\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {string} signature\n     * @param {string} data\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * Assert Sufficient Key Length\n     *\n     * @description Assert that the key length is sufficient\n     * @param {string} key\n     */\n\n  }, {\n    key: 'assertSufficientKeyLength',\n    value: function assertSufficientKeyLength(key) {\n      if (key.length < this.bitlength) {\n        throw new Error('The key is too short.');\n      }\n    }\n  }]);\n\n  return HMAC;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = HMAC;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/HMAC.js","'use strict';\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = require('base64url');\nvar crypto = require('@trust/webcrypto');\nvar TextEncoder = require('../text-encoder');\n\n/**\n * RSASSA-PKCS1-v1_5\n */\n\nvar RSASSA_PKCS1_v1_5 = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function RSASSA_PKCS1_v1_5(params) {\n    _classCallCheck(this, RSASSA_PKCS1_v1_5);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(RSASSA_PKCS1_v1_5, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO\n      //if (!this.sufficientKeySize()) {\n      //  return Promise.reject(\n      //    new Error(\n      //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n      //    )\n      //  )\n      //}\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return RSASSA_PKCS1_v1_5;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = RSASSA_PKCS1_v1_5;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/RSASSA-PKCS1-v1_5.js","'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar NotSupportedError = require('../errors/NotSupportedError');\n\n/**\n * Operations\n */\nvar operations = ['sign', 'verify', 'encrypt', 'decrypt', 'importKey'];\n\n/**\n * SupportedAlgorithms\n */\n\nvar SupportedAlgorithms = function () {\n\n  /**\n   * constructor\n   */\n  function SupportedAlgorithms() {\n    var _this = this;\n\n    _classCallCheck(this, SupportedAlgorithms);\n\n    operations.forEach(function (op) {\n      _this[op] = {};\n    });\n  }\n\n  /**\n   * Supported Operations\n   */\n\n\n  _createClass(SupportedAlgorithms, [{\n    key: 'define',\n\n\n    /**\n     * define\n     *\n     * @description\n     * Register Web Crypto API algorithm parameter for an algorithm\n     * and operation.\n     *\n     * @param {string} alg\n     * @param {string} op\n     * @param {Object} argument\n     */\n    value: function define(alg, op, argument) {\n      var registeredAlgorithms = this[op];\n      registeredAlgorithms[alg] = argument;\n    }\n\n    /**\n     * normalize\n     *\n     * @description\n     * Map JWA alg name to Web Crypto API algorithm parameter\n     *\n     * @param {string} op\n     * @param {Object} alg\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(op, alg) {\n      var registeredAlgorithms = this[op];\n\n      if (!registeredAlgorithms) {\n        return new SyntaxError(); // what kind of error should this be?\n      }\n\n      var argument = registeredAlgorithms[alg];\n\n      if (!argument) {\n        return new NotSupportedError(alg);\n      }\n\n      return argument;\n    }\n  }], [{\n    key: 'operations',\n    get: function get() {\n      return operations;\n    }\n  }]);\n\n  return SupportedAlgorithms;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = SupportedAlgorithms;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/SupportedAlgorithms.js","'use strict';\n\n/**\n * Local dependencies\n */\nvar HMAC = require('./HMAC');\nvar ECDSA = require('./ECDSA');\nvar RSASSA_PKCS1_v1_5 = require('./RSASSA-PKCS1-v1_5');\nvar SupportedAlgorithms = require('./SupportedAlgorithms');\n\n/**\n * Register Supported Algorithms\n */\nvar supportedAlgorithms = new SupportedAlgorithms();\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('KS256', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'K-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES256', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES384', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('ES512', 'sign', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\nsupportedAlgorithms.define('none', 'sign', {});\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('KS256', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'K-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES256', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES384', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('ES512', 'verify', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\nsupportedAlgorithms.define('none', 'verify', {});\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('KS256', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'K-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES256', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('ES384', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('ES512', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  namedCurve: 'P-256',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms;\n\n\n// WEBPACK FOOTER //\n// ./lib/algorithms/index.js","'use strict';\n\nmodule.exports = {\n  DataError: require('./DataError'),\n  NotSupportedError: require('./NotSupportedError')\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/errors/index.js","'use strict';\n\n/**\n * Package dependencies\n */\nvar _require = require('@trust/json-document'),\n    Formats = _require.Formats;\n\n/**\n * Format extensions\n */\n\n\nFormats.register('StringOrURI', new RegExp());\nFormats.register('NumericDate', new RegExp());\nFormats.register('URI', new RegExp());\nFormats.register('url', new RegExp());\nFormats.register('base64', new RegExp());\nFormats.register('base64url', new RegExp());\nFormats.register('MediaType', new RegExp());\n\n\n// WEBPACK FOOTER //\n// ./lib/formats/index.js","'use strict';\n\n/**\n * Dependencies\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = require('@trust/json-document'),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSetSchema = require('../schemas/JWKSetSchema');\nvar JWK = require('./JWK');\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\n\nvar JWKSet = function (_JSONDocument) {\n  _inherits(JWKSet, _JSONDocument);\n\n  function JWKSet() {\n    _classCallCheck(this, JWKSet);\n\n    return _possibleConstructorReturn(this, (JWKSet.__proto__ || Object.getPrototypeOf(JWKSet)).apply(this, arguments));\n  }\n\n  _createClass(JWKSet, null, [{\n    key: 'importKeys',\n\n\n    /**\n     * importKeys\n     */\n    value: function importKeys(jwks) {\n      var validation = this.schema.validate(jwks);\n\n      if (!validation.valid) {\n        return Promise.reject(new Error('Invalid JWKSet: ' + JSON.stringify(validation, null, 2)));\n      }\n\n      if (!jwks.keys) {\n        return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'));\n      }\n\n      var imported = void 0,\n          importing = void 0;\n\n      try {\n        imported = new JWKSet(jwks);\n        importing = jwks.keys.map(function (key) {\n          return JWK.importKey(key);\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n\n      return Promise.all(importing).then(function (keys) {\n        imported.keys = keys;\n        return imported;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWKSetSchema;\n    }\n  }]);\n\n  return JWKSet;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWKSet;\n\n\n// WEBPACK FOOTER //\n// ./lib/jose/JWKSet.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPatch = require('./JSONPatch');\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONDocument;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONDocument.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = require('./JSONPointer');\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONMapping;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONMapping.js","'use strict';\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = require('./Initializer');\nvar Validator = require('./Validator');\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONSchema;\n\n\n// WEBPACK FOOTER //\n// ./~/@trust/json-document/lib/JSONSchema.js","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64-js/index.js","\"use strict\";\nvar pad_string_1 = require(\"./pad-string\");\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(new Buffer(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return new Buffer(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return new Buffer(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = base64url;\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64url/dist/base64url.js","\"use strict\";\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = new Buffer(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = padString;\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64url/dist/pad-string.js","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/ieee754/index.js","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/isarray/index.js","module.exports = TextEncoder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"TextEncoder\"\n// module id = 40\n// module chunks = 0"],"sourceRoot":""}